#!/usr/bin/python

import os
import time
import datetime
import nvmectl
import nvmectlparser


# Create Namespaces (with the default namespaces as per NVMe for iOS).
def create_namespaces(ctl, info, args):
    namespaces = []
    device_type = ctl.GetDeviceType()

    if args.namespace:
        for ns in args.namespace:
            namespaces.append((ns[0], ns[1], ns[2]))
    elif device_type == nvmectl.kNVMeDeviceS3E or device_type == nvmectl.kNVMeDeviceANS2QB or device_type == nvmectl.kNVMeDeviceANS2:
        namespaces.append((1, 1, 0))
        namespaces.append((2, 2, 2048))
        namespaces.append((3, 3, 32))
        namespaces.append((4, 4, 2))
        namespaces.append((5, 5, 2))
        namespaces.append((6, 6, 1))
        namespaces.append((7, 8, 256))
    elif device_type == nvmectl.kNVMeDeviceS3X:
        namespaces.append((1, 1, 0))
        namespaces.append((2, 6, 2))
    else:
        print(('Error: Invalid device type. ({})'.format(device_type)))
        return 1

    print("Sending the following namespaces with Create Namespaces:")
    buf = nvmectl.NVMeCreateNamespacesStruct()
    buf.NUM_OF_NAMESPACES = 0

    for ns in namespaces:
        print("Namespace %d - type %d size %d" % (ns[0], ns[1], ns[2]))
        ctl.AppendNamespace(buf, ns[0], ns[1], ns[2])

    retval = ctl.CreateNamespaces(buf)
    print((nvmectlparser.status_str.format(r=retval)))
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Create namespaces', r=retval)))
        return retval.fReturn

    return 0

create_namespaces_parser = nvmectlparser.subparsers.add_parser("CreateNamespaces", help="Execute CreateNamespaces commands, send the default namespaces (as per NVMe for iOS).")
create_namespaces_parser.add_argument("-n", "--namespace", metavar=("ID", "TYPE", "NBLOCKS"), nargs=3, type=int, action="append",
                                      help="Define custom namespaces scheme. Multiple -n flags are allowed.")
create_namespaces_parser.set_defaults(func=create_namespaces)


# Delete Namespaces (Create namepsaces with 0).
def delete_namespaces(ctl, info, args):
    buf = nvmectl.NVMeCreateNamespacesStruct()
    buf.NUM_OF_NAMESPACES = 0

    retval = ctl.CreateNamespaces(buf)
    print((nvmectlparser.status_str.format(r=retval)))
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Create namespaces', r=retval)))
        return retval.fReturn

    return 0

delete_namespaces_parser = nvmectlparser.subparsers.add_parser("DeleteNamespaces", help="Delete all namespaces.")
delete_namespaces_parser.set_defaults(func=delete_namespaces)


# Perform a boot from host procedure
def set_scratchpad(ctl, info, args):
    try:
        size = os.path.getsize(args.input_file)
    except:
        size = 0
    if size == 0:
        size = ctl.ReadRegister32(nvmectl.kNVMe_DDRSIZE_Offset)
    if size == 0 or size == 0xFFFFFFFF:
        size = ctl.ReadRegister32(nvmectl.kNVMe_DDRREQSIZE_Offset)
    if size == 0 or size == 0xFFFFFFFF:
        print('Error: Scratchpad size is unknown.')
        return 1

    buf = nvmectlparser.file_to_buff(args.input_file, size)
    if buf is None:
        print("Error: Failed reading input file.")
        return 1
    status = ctl.SetScratchpad(buf, size)
    if status != 0:
        print(('SetScratchpad failed. status={:#x}'.format(status)))
        return status

    if args.set_registers:
        status = ctl.SetScratchpadRegisters()
        if status != 0:
            print(('SetScratchpadRegisters failed. status={:#x}'.format(status)))

    return status

set_scratchpad_parser = nvmectlparser.subparsers.add_parser("SetScratchpad", help="Initialize and set the DDR scratchpad.")
set_scratchpad_parser.add_argument("input_file", help="A file containing the entire contenst of the scratchpad to set.")
set_scratchpad_parser.add_argument("-r", "--set-registers", action="store_true", help="After setting the scratchpad, also set the drive's scratchpad registers.")
set_scratchpad_parser.set_defaults(func=set_scratchpad)


# return a char array with the scratchpad buffer.
def get_scratch_buffer(ctl, length):
    buf = nvmectl.ucharArray(length)
    result = ctl.GetDriverData(nvmectl.kNVMeDriverScratchpad, buf, length)
    if result[0] != 0:
        print(('Error: GetDriverData failed. (result[0]={:#x})'.format(result[0])))
        return None

    return buf


def poll_register(ctl, offset, required_value, timeoutSecs):
    for i in range(timeoutSecs):
        value = ctl.ReadRegister32(offset)
        if value == required_value:
            return True
        else:
            time.sleep(1)

    print(("poll_register failed. offset={:#x}, required_value={:#x}, "
          "timeout={}, last_value={:#x}".format(offset, required_value, timeoutSecs, value)))
    return False


# Delete Namespaces (Create namepsaces with 0).
def get_s3e_fa(ctl, info, args):
    assert_info = ctl.GetCurrentAssert()
    if assert_info.fID == 0 or assert_info.fID == 0xFFFFFFFF:
        print('No assert found. FA is not available.')
        return 1
    else:
        print(('Assert params: {v.fID} ({v.fArg1:#x} {v.fArg2:#x} {v.fArg3:#x})'.format(v=assert_info)))

    length = ctl.ReadRegister32(nvmectl.kNVMe_DDRREQSIZE_Offset)
    if length == 0 or length == 0xFFFFFFFF:
        print('Error: scratchpad size is set to 0')
        return 1

    if args.scratchpad_file is not None:
        ctl.WriteRegister32(nvmectl.kNVMe_S3E_FA_Action_Offset, 1)
        if not poll_register(ctl, nvmectl.kNVMe_S3E_FA_Status_Offset, 1, 10):
            return 1
        scratch_buf = get_scratch_buffer(ctl, length)
        if scratch_buf is None:
            return 1
        status = ctl.WriteBufferToFile(scratch_buf, length, args.scratchpad_file)
        if status != 0:
            print(('Error: Failed writing data to file. ({})'.format(os.strerror(status))))
            return 1

    ctl.WriteRegister32(nvmectl.kNVMe_S3E_FA_Action_Offset, 2)
    if not poll_register(ctl, nvmectl.kNVMe_S3E_FA_Status_Offset, 2, 10):
        return 1
    fa_length = ctl.ReadRegister32(nvmectl.kNVMe_S3E_FA_Length_Offset)
    fa_buf = get_scratch_buffer(ctl, length)
    if fa_buf is None:
        return 1
    if args.fa_file:
        status = ctl.WriteBufferToFile(fa_buf, fa_length, args.fa_file)
        if status != 0:
            print(('Error: Failed writing data to file. ({})'.format((os.strerror(status)))))
        return 1
    else:
        dir_name = '{}-{}'.format(info.fSerial, datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S"))
        full_path = os.path.join(args.fa_dir, dir_name)
        os.makedirs(full_path)
        ret = ctl.S3XWriteFAFiles(full_path, fa_buf.cast(), fa_length, None)
        if ret != 0:
            print(('Error: Failed writing FA data. (error={})'.format(ret)))
            return 1

    return 0

get_s3e_fa_parser = nvmectlparser.subparsers.add_parser("GetS3EFA", help="Get S3E FA. S3E only. Asserted devices only.")
get_s3e_fa_parser.add_argument("-s", "--scratchpad-file", metavar="FILE", help="Save scratchpad contents to the specified file. Optional")
get_s3e_fa_group = get_s3e_fa_parser.add_mutually_exclusive_group(required=True)
get_s3e_fa_group.add_argument("-f", "--fa-file", metavar="FILE", help="Dump FA buffer to the specified file.")
get_s3e_fa_group.add_argument("-d", "--fa-dir", metavar="DIR", help="Parse FA buffer. Write parsed FA to the specified dir.")
get_s3e_fa_parser.set_defaults(func=get_s3e_fa)
