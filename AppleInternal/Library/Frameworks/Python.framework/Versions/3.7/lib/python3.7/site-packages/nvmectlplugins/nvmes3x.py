#!/usr/bin/python

import nvmectl
import nvmectlparser
import os


# Perform a boot from host procedure
def perform_bfh(ctl, info, args):
    if not os.path.isfile(args.image_file):
        print(('Error: {} does not exist, or is a directory.'.format(args.image_file)))
        return 1
    buf_size = os.path.getsize(args.image_file)
    buf = nvmectl.charArray(buf_size)

    num_read = ctl.ReadBufferFromFile(buf, buf_size, args.image_file)
    if num_read != buf_size:
        print(('Error: Failed reading data from file. ({})'.format(os.strerror(-num_read))))
        return -num_read

    status = ctl.PerformBFH(buf, buf_size)
    print(('status={:#x}'.format(status)))
    return status

perform_bfh_parser = nvmectlparser.subparsers.add_parser("PerformBFH", help="Perform a boot from host procedure.")
perform_bfh_parser.add_argument("image_file", help="The binary firmware image file.")
perform_bfh_parser.set_defaults(func=perform_bfh)


def get_bfh_status(ctl, info, args):
    retval = ctl.GetBFHStatus()
    print(retval)
    return retval

get_bfh_status_parser = nvmectlparser.subparsers.add_parser("GetBFHStatus", help="Read the BFH status register (offset 0x1B14).")
get_bfh_status_parser.set_defaults(func=get_bfh_status)


def schedule_bg(ctl, info, args):
    retval = ctl.ScheduleBG()
    print((nvmectlparser.status_str.format(r=retval)))
    return retval.fReturn

schedule_bg_parser = nvmectlparser.subparsers.add_parser("ScheduleBG", help="Send Schedule BG refresh command.")
schedule_bg_parser.set_defaults(func=schedule_bg)


def set_timestamp(ctl, info, args):
    retval = ctl.SetTimestamp()
    print((nvmectlparser.status_str.format(r=retval)))
    return retval.fReturn

set_timestamp_parser = nvmectlparser.subparsers.add_parser("SetTimestamp", help="Send Set timestamp command.")
set_timestamp_parser.set_defaults(func=set_timestamp)


# Set encryption parameters.
def set_encryption_params(ctl, info, args):
    aes_map = {"none": [0, 0], "128": [1, 32], "192": [2, 48], "256": [3, 64]}

    security_mode = aes_map[args.aes_mode][0]
    if security_mode == nvmectl.kNVMeSecurityModeNone and args.key_file is not None:
        print("Error: Cannot specify --key-file with --aes-mode=none.")
        return 1
    if security_mode != nvmectl.kNVMeSecurityModeNone and args.key_file is None:
        print("Error: --key-file is required --aes-mode!=none.")
        return 1
    if security_mode != nvmectl.kNVMeSecurityModeNone and not os.path.exists(args.key_file):
        print(("Error: {} does not exist.".format(args.key_file)))
        return 1

    key_buf = None
    key_size = aes_map[args.aes_mode][1]
    if key_size > 0:
        key_buf = nvmectl.charArray(key_size)
        num_read = nvmectl.NVMeCTL_ReadBufferFromFile(key_buf, key_size, args.key_file)
        key_file_size = os.path.getsize(args.key_file)
        if num_read < key_size or key_size < key_file_size:
            print(("Error: Key file size ({} bytes) does not match required size for "
                  "specified AES type. ({} bytes)".format(key_file_size, aes_map[args.aes_mode][1])))
            return 1

    status = ctl.SetEncryptionParams(key_buf, security_mode)
    print(('status={:#x}'.format(status)))
    return status

set_encryption_params_parser = nvmectlparser.subparsers.add_parser("SetEncryptionParams", help="Set static encryption key/mode to be used on all IOs")
set_encryption_params_parser.add_argument("-k", "--key-file", help="A file containing a key to encrypt the IO with.")
set_encryption_params_parser.add_argument("-m", "--aes-mode", required=True, choices=["none", "128", "192", "256"],
                                          help="The key sizes used in the key file.")
set_encryption_params_parser.set_defaults(func=set_encryption_params)
