<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>CrashTester</title>
	</head>
<body>

<h1>CrashTester</h1>

<h2>Introduction</h2>

<p>CrashTester is an app, framework, plugin interface and set of cluster node apps that provide a framework for distributing a grid of tasks across a cluster. We use it to test vImage, LAPACK and other Accelerate.framework components. It is best suited to large, often exhaustive test loads across a diversity of machines. CrashTester and associated components live in /AppleInternal/CoreOS/CrashTester. </p>

<h2>How to Use CrashTester</h2>

<p>CrashTester clients each write a plugin for their segment of the test. The plugin links to the libraries / frameworks that need to be tested and implement the domain specific test code for that library/framework. To Use, simply select the test (or many such) from the Tests menu, set the architecture (i386, x86_64, arm, arm64) and hit Go in the main window. Provided that there are cluster nodes connected to CrashTester.app, it should begin testing and the progress bar should begin to fill with green areas, denoting tests that have passed. Magenta indicates failure. Black indicates a test is planned but hasn’t run yet. White indicates either no test is planned, or the app hasn’t looked far enough ahead in the test grid to see whether one is planned there or not. </p>

<p>What is a test grid? Each test in the plugin is broken up into a 2D grid of individual sub-tests. The X and Y coordinates in the grid might represent 200 array sizes by 32 alignments, or maybe all 53 kinds of images by all 274 legal permutations of flags bits in your interface. You might pick a very abstract set of coordinates that make sense only to you. Whatever the grid dimensions represent, CrashTester doesn’t know or care.<sup><a id="ffn1" href="#fn1" class="footnote">1</a></sup> </p>

<h3>The Test Grid </h3>

<p>Each test specifies the size of its own grid. The limits of the grid should bound what is a tractable test case for the test code. For example, if you preallocate the input arrays to save time, the grid size might be the set of test sizes that fit in those arrays. The number of grid points should be at least as many as the number of cluster nodes on the cluster, or your parallelism will suffer. The grid points don’t need to take the same amount of time to run.</p>

<p>The test does not need to test the entire grid, but can just test a subset to keep the load down. This is accomplished either by having the plugin create a reduced set of test cases to run for each grid row, or by running in Monte Carlo mode, which causes CrashTester to just select test cases at random and run until stopped. </p>

<h3>Responding to Failure Cases</h3>

<p>Success is easy. There is little to do but send your Radar off for approval. If CrashTester detects a failure, it will be listed at the bottom of the main window in a NSOutlineView. You might need to open a disclosure triangle or two. </p>

<p>You can:</p>

<ul>
	<li>Save the failure cases for later, using the File -&gt; Save command. This is useful for attaching to Radars.</li>
	<li>Attempt to rerun all the failures on the cluster again to see which ones reproduce there. </li>
	<li>Attempt to reproduce a single failure case locally. Double click a failure case in the main window and it will be copied to the Run Single Test Case window. There more information will be displayed about the failure including the grid location of the test, some human readable spew to help you position a breakpoint at the approximate point of failure, and some controls to let you adjust what is tested. <img src="Screen%20Shot%202014-06-17%20at%201.20.10%20PM.png"/> Hit Go again, and the test will be rerun in the CrashTester.app process (if the arch matches) or run on one of the client nodes if it doesn’t.<sup><a id="ffn2" href="#fn2" class="footnote">2</a></sup> </li>
</ul>

<p>Our typical test session involves running the test for a few seconds until it fails, copy a failure case to the Run Single Test Case window, place a breakpoint at the file and line indicated and click Go. The process will repeat the test, stop and the breakpoint and then we can step through the failure case to see what went wrong.</p>

<h3>Building a Cluster</h3>

<p>The cluster is made up of a collection of ct_client processes running on various machines connected via the network. For OS X, just launch a copy of the client as follows:</p>

<pre><code>./ct_client MyCrashTesterHost.apple.com &amp;
</code></pre>

<p>Here substitute in the name of the machine running CrashTester.app for MyCrashTesterHost. You can launch on iOS by first opening up a port from the device on the OS X host using tcprelay:</p>

<pre><code>tcprelay --portoffset 10000 --serialnumber &lt;device ser num&gt; localhost:7070 localhost:7071 &amp;
</code></pre>

<p>and then running the client on the device:</p>

<pre><code>../ct_client_purple localhost &amp;
</code></pre>

<p>iOS clients can also connect through Wifi as OS X machines do provided that the iOS device has a radio and there is no firewall preventing contact in-between the two. As a shortcut, there is a “Launch iOS Clients…” button on the main window, which will launch tcprelay for you, copy a directory full of stuff to the device for you<sup><a id="ffn3" href="#fn3" class="footnote">3</a></sup> and then remotely launch ct_client_purple for you for all the iOS devices connected directly to that Mac. </p>

<p>Devices that successfully connect will be listed in a Client List window. There are some controls there for suspending clients and booting them from the cluster. </p>

<figure><img src="Screen%20Shot%202014-06-17%20at%203.39.43%20PM.png" title="Client list for x86\_64"/></figure>

<p>The display shows attached client by process ID. If the name is in Red, the client doesn’t support the full set of vector ISA extensions asked for by the test config. This is usually not a problem. It is flagged in case we are trying to build a homogenous cluster and a different machine slips in there by mistake.</p>

<hr />

<h2>Components Overview</h2>

<p>The following software components make up CrashTester:</p>

<h3>CrashTester.app</h3>

<p>CrashTester.app serves as the central cluster node. It provides a GUI for selecting which tests to run, monitoring their progress, evaluating errors returned by clients and for debugging test code and the framework code that it tests. It runs on OS X. When it launches, it automatically spawns a bunch of ct_clients on the host system. It is also CoreAutomation aware and is capable of launching ct_client versions on attached iOS devices.</p>

<h3>ct_client</h3>

<p>ct_client is a CLI binary that serves as a compute node for the cluster. It can run on either OS X or iOS. See ct_client —help for information about options when running ct_client. It connects to CrashTester.app through TCP/IPv6. </p>

<pre><code>./ct_client mymachine.apple.com &amp;
</code></pre>

<p>where mymachine.apple.com is a machine running CrashTester.app.</p>

<p>On iOS, you can either connect through WiFi as described above, or through the cable. To connect through the cable, you need to have tcprelay running. Here is a sample invocation on the OS X side:</p>

<pre><code>tcprelay —portoffset 10000 —serial number &lt;ser_num&gt; localhost:7070 localhost:7071 &amp;
</code></pre>

<p>The serial number can be obtained using tcprelay —list. </p>

<p>On the iOS side, you just run:</p>

<pre><code>./ct_client localhost
</code></pre>

<p>and the client should attach if all is well.</p>

<p>If it fails to connect to a host, it will usually quit in a few seconds. There is an automatic log of ct_client activity kept in /var/tmp. It might also drop off the cluster if the automatic library verification feature determines it is using the wrong version of your framework.</p>

<p>ct_client is also capable of standalone operation. It can run all the tests it knows about, though progress is usually much slower because only a single cluster node is being used. Use the --help option for more information. It is sometimes more convenient to debug code this way. Typically, one runs the test until some errors are detected. These are automatically logged by default to a .errs file in /var/tmp. Then relaunch ct_client in the debugger with either of these:</p>

<pre><code>./ct_client -run-errs /path/to/file.errs
./ct_client -run-last-errs
</code></pre>

<p>The second option automatically loads the most recent .errs file in /var/tmp. That will cause just the failure cases to be re-run, which should allow you to quickly reproduce the problems.</p>

<h3>CrashTester plugins</h3>

<p>In order to allow CrashTester to be used by a number of different projects, the tests themselves are written as plugins. </p>

<p>The plugins define a list of child classes of a Job class. </p>

<p>Jobs so created are sent over TCP/IP to attached ct_clients, unpacked and run. The job class records the result, and is then sent back over the connection to the OS X host where the results are displayed. All Jobs can be serialized for sending over the network or storing to disk.</p>

<blockquote>
<p>Because we need to remain flexible in the face of new architectures which may initially lack C++ or Obj C compilers, plugins, including the above mentioned classes, are written in C as structs with a pointer to an explicit virtual function table which defines class behavior. Please see CrashTestPlugin.h for more info.</p>
</blockquote>

<h3>CrashTest.framework</h3>

<p>A number of library routines are necessary to the correct function of CrashTester plugins are in CrashTest.framework. These include the base class for Job, interfaces for loading plugins and gathering metadata about them, an exception handling mechanism (in C) and a logging facility. These are kept in CrashTest.framework. All plugins should link to CrashTest.framework.</p>

<hr />

<h2>How to Create a Test Plugin</h2>

<p>The following steps enumerate how to make a new CrashTester plugin:</p>

<h3>1) Register the Plugin</h3>

<p>Have a ReservedPluginID added to &lt;CrashTest/CrashTestPlugin.h&gt;. We need a fixed plugin ID for file format compatibility between machines. If you do not have access to the CrashTester source, file a Radar against Accelerate/X asking for the ID to be allocated. </p>

<h3>2) Create a .ctplugin</h3>

<p>Add a dynamic library target to your build as your CrashTest plugin. The plugin search path is:</p>

<pre><code>getenv( &quot;CRASHTESTER\_PLUGIN\_PATH&quot;)
${HOME}/Library/Application Support/CrashTester/Plugins
/AppleInternal/CoreOS/CrashTester/Plugins
</code></pre>

<p>so your library should install into one of those places. The dylib file name must end with .ctplugin instead of .dylib. </p>

<p>The plugin shall link to CrashTest.framework and implement the functions declared in CrashTest/CrashTestPlugin. Currently, that is only this function:</p>

<pre><code>const CrashTestList *  CrashTestPlugin_GetTests( void );
</code></pre>

<p>You may use the following exports file to make sure that nothing else is exported, if you like:</p>

<p>CrashTestPlugin.exp:</p>

<blockquote>
<p>#Required plugin Interface</p>

<p>_CrashTestPlugin_GetTests</p>

<p>#File must end with a newline</p>
</blockquote>

<p>The plugin can define up to 255 tests. The class definition for these appears in CrashTestList.testList. </p>

<h3>3) Add Tests to the Plugin</h3>

<p>Each test is a subclass of the Job class. To implement a subclass, make a new struct which contains the Job struct as its first field.</p>

<pre><code>typedef struct MyJob{
	Job parent;
	int myField;
} MyJob;
</code></pre>

<p>The behavior of the new Job child class is given by the class vtbl. Since this is C, we have to define that by hand, but it is not too onerous. In your MyJob.c file, add a global struct:</p>

<pre><code>Job_vtbl MyJob_vtbl {
.parent = JobBase_vtbl_p,
.publicName = &quot;MyJob&quot;,
.subTestList = gMySubTestNames, 
.jobType = kJobType_None,
.jobSize = sizeof(MyJob),
.reducedGridSize = { kSizeCount, kSizeCount},
.fullGridSize = {255, 255},

// Must define these
.DoJobWithContext = MyJob_DoJobWithContext,
.InitBuffers = MyJob_InitBuffers,
.convertReducedPositionToFullPosition = MyJob_convertReducedToFull,

// Since we added a field to Job, we need these optional
//methods to handle the extra data
.Init = MyJob_init,
.print = MyJob_print,
.FlattenIntoBuffer = MyJob_flattenIntoBuffer,
.FlattenedSize = MyJob_FlattenedSize,
.InitWithFlattenedBuffer = MyJob_initWithFlattenedBuffer

// The rest we don&#39;t need to override and can be left as NULL
};
</code></pre>

<p>You need to add a pointer to the Job_vtbl you just made to your plugin’s CrashTestList. Pure virtual Job subclasses do not need to be added to the CrashTestList. They will be initialized when their non-pure virtual child classes are initialized.</p>

<p>The rest of the work consists of providing an implementation for the function pointers in the vtbl. These are described in the following sections:</p>

<h4>Class Data</h4>

<h5>parent</h5>

<p>The job class supports polymorphic access through virtual functions. If you don’t define a virtual function here (leave it NULL), then when the plugin is loaded, CrashTest will use the method defined for the parent class. A pointer to the Job_vtbl for the parent class is kept here. If you did not define a parent class of your own, then you must use JobBase_vtbl_p here.</p>

<h5>public_name</h5>

<p>This is the name of the test as it will appear in CrashTester hierarchical menus and result displays. If the class is intended to be pure virtual or otherwise should not appear in the public list, use NULL here.</p>

<h5>subtestNameList</h5>

<p>Typically a Job will actually test multiple functions. It is usually useful to gang multiple functions together to reduce setup time which might be shared for all. We have found through long experience that this heavier test design makes it tempting for users to comment out the unwanted part of the test, to make it run faster for the particular function they are looking at that day. Infrequently, the comment marks get checked in by mistake, and then large segments of the test stay disabled for a while until someone discovers the error. </p>

<p>To avoid this problem, the tests have a optional list of subtests attached to them (see Job_getSubTestList()) to allow users to turn off individual functions in the test without modifying the source. If your Job_vtbl.DoJobWithContext() implements this feature, you should provide a list of names in subTestList corresponding to individually enablable parts of the test, so the user can configure the test correctly. Later, when Job_vtbl.DoJobWithContext() is called Job_getSubTestList() will either return NULL, in which case test everything, or it will return a list of subtests to test, and your Job_vtbl.DoJobWithContext() should just test those.</p>

<h5>verificationSymbol</h5>

<p>As part of its operation, CrashTester can verify that all versions of the client have loaded the right library. The verificationSymbol is a const C string that contains the name of one of the functions being tested. The vImage Alpha test might have “vImageAlphaBlend_ARGB8888” here. </p>

<p>CrashTester will get the binary that contains the symbol and then check the mach-o library version number and timestamp against that of other ct_clients already connected to the cluster to make sure it matches.<sup><a id="ffn4" href="#fn4" class="footnote">4</a></sup> </p>

<h5>jobType </h5>

<p>Each Job class needs a unique ID so it can be identified after serializing to a file or network stream. This ID is created as:</p>

<pre><code> Job_vtbl.jobType = ReservedPluginID + localTestID;
</code></pre>

<p>Here, the ReservedPluginID is the ID number assigned for your plugin (see &lt;CrashTest/CrashTestPlugin.h&gt; and localTestID is a number in the range [0.255] that is not shared by any other Job Class defined by your plugin.</p>

<h5>jobSize</h5>

<p>So as to streamline creation of Job subclass objects, the implementation needs to know how big your subclass is. The size includes the size of the Job base class.</p>

<pre><code>Job_vtbl.jobSize = sizeof( MyJobSubclass );
</code></pre>

<h5>reducedGridSize</h5>

<p>Typically Jobs are defined to search a large 2D search space of tests. For example, the code for a simple test of image processing functionality might be designed to test every image height and width in combination from [0,255]. Perhaps we also want to test 32 different input alignments and 32 different output alignments. Suddenly, we have 67 million test cases to try. That might take a while. </p>

<p>In standard operation, the search space is reduced down a bit to a smaller grid. We might only search the image sizes from 0-17 plus a few larger sizes. The size of the smaller grid in each dimension is given by Job_vtbl.reducedGridSize. </p>

<p>The reduced grid may be be sparsely occupied.</p>

<h5>fullGridSize</h5>

<p>Typically Jobs are defined to search a large 2D search space of tests. This defines the limits of that search space for which behavior is defined. See description of Job_vtbl.reducedGridSize above for more information.</p>

<h4>Class Virtual Functions</h4>

<h5>DoJobWithContext</h5>

<p>The actual test code goes in here. You can put anything you like in there. Your Job subclass is passed to it as an argument, so any data you need can be attached to the Job subclass for use here. DoJobWithContext is never called from multiple threads concurrently in the same process. You can call multithreaded code from here, if you like.</p>

<p>In typical use, your Job subclass will be instantiated as thousands or millions of objects. DoJobWithContext will be called once for each of these, one after another in quick succession. There may be some expensive reusable resources like arrays of input data or lookup tables that can be reused from test to test. These should be placed in the CTBufferContext, which is passed in as the second argument of DoJobWithContext. See the InitBuffers discussion below. </p>

<p><strong>Some recommended practice:</strong></p>

<ul>
	<li>Move expensive initialization work to the CTBufferContext</li>
	<li>Use the Job-&gt;loops[] counters to track progress as you move through the test. This allows you to jump straight to the problem case when trying to reproduce an error later:</li>
</ul>

<pre><code>int MyJob_DoJobWithContext( struct Job *j, CTBufferContext *c ){
   ...
   
   // start loop at last saved position so we jump straight to
   // failure case when reproducing
   for( alignment = j-&gt;loops[0]; alignment &lt; 16; alignment++){
        job-&gt;loops[0] = j;  // save loop progress
  
        RunTest( c, alignment );
   }
   // if the test finishes successfully, reset loops counters
   j-&gt;loops[0] = j-&gt;loops[1] = j-&gt;loops[2] = j-&gt;loops[3] = 0;
}
</code></pre>

<ul>
	<li>Use the job subtest list to let the user control which things to test. This will help avoid problems later with chunks of tests being commented out and checked in:</li>
</ul>

<pre><code>int MyJob_DoJobWithContext( struct Job *j, CTBufferContext *c ){
   SubTestID *list = Job_getSubTestList(j);
   
   if( NULL == list ){
      for( subtest = 0; subtest &lt; kTestCount; subtest++)
		RunSubtest(subtestID);
   }
   else{
       unsigned long count = list[0];
       for( subtest = 1; subtest &lt;= count; subtest++ )
          RunSubtest( list[subtest] );
   }
}
</code></pre>

<ul>
	<li>Throw an error if you encounter a test failure. There is no sense finishing out the test if it has already found an error. Most of the time, you’d just discover the same error over and over again:</li>
</ul>

<pre><code>#include &lt;CrashTest/CTTesting.h&gt;
int MyJob_DoJobWithContext( struct Job *j, CTBufferContext *c ){
   ...
      int err = TestFunc1(j, c);
      if( err )
         CTThrowError( kVectorError, err, __LINE__, __FILE__,
                 “Func1Name”, “some informative err message” );
   ...
}
</code></pre>

<ul>
	<li>If your function operates on arrays, allocate them in CTBufferContext with guard pages on the ends. Allocate the array + extra space for guard pages using mmap(). Protect the ends with mprotect().</li>
</ul>

<h5>InitBuffers</h5>

<p>The CTBufferContext is an opaque structure that you define. Typically, you would make a new struct which uses CTBufferContext as its first field, and add additional information to it as needed to support the test code in DoJobWithContext. </p>

<pre><code>typedef struct MyCTBufferContext{
	CTBufferContext parent;
	uint8_t *inputArray;  // data I need for DoJobWithContext()
} MyCTBufferContext;
</code></pre>

<p>CrashTester calls MyJob.InitBuffers() to create the context just before the first time MyJob.DoJobWithContext() is called, and frees it after it is done calling MyJob.DoJobWithContext() and has moved on to other work. It is intended to hold input data buffers and other expensive reusable objects which are needed in DoJobWithContext() but which should not be allocated there, typically for performance reason. </p>

<pre><code>const CTBufferContext * MyJob_InitBuffers {
	MyCTBufferContext *newContext = malloc(sizeof(*newContext));
	if( NULL == newContext )
		 return NULL;
	newContext-&gt;free = MyJob_CTBufferContextFree;
	newContext-&gt;inputArray = MakeInputArray();
	return &amp;newContext-&gt;parent;
}
</code></pre>

<p>In cases where a CTBufferContext is not needed, perhaps because DoJobWithContext() doesn’t do very much, then InitBuffers can return NULL.</p>

<p>The CTBufferContext holds a function pointer to a free() routine. If non-NULL, this is used when it is time to delete the context. It serves as both a destructor and deallocator. </p>

<pre><code>void MyJob_CTBufferContextFree( CTBufferContext *c){
	MyCTBufferContext *ctx = (MyCTBufferContext *) c;
	free( c-&gt;inputArray );
	free( c);
}
</code></pre>

<h5>convertReducedPositionToFullPosition</h5>

<p>Typically Jobs are defined to search a large 2D search space. For example, the code for a simple test of image processing functionality might be designed to test every image height and width in combination from [0,255]. Perhaps we also want to test 32 different input alignments and 32 different output alignments. Suddenly, we have 67 million test cases to try. That might take a while. </p>

<p>In standard operation, the search space is reduced down a bit to a smaller grid. The size of the smaller grid is given by Job_vtbl.reducedGridSize. This function takes a coordinate from the smaller grid and returns the coordinate in the full size grid. </p>

<pre><code>// the subset of array sizes we want to test
static const kSizesToTest[5] = { 0, 1, 2, 5, 255 };
static const int kSizesCount = sizeof(kSizesToTest) / 
                              sizeof(kSizesToTest[0];
// our vtbl definition
Job_vtbl MyJob_vtbl = {
   .reducedGridSize = {kSizesCount,kSizesCount},
   .fullGridSize = { 255, 255 }, 
};

Job_GridPosition MyJob_convertReducedToFull( const Job_GridPosition *reduced) {
   return (Job_GridPosition){kSizesToTest[reduced-&gt;x], 
                             kSizesToTest[reduced-&gt;y] };
}
</code></pre>

<p>In some circumstances, it is desirable to have the reduced grid space to be sparsely populated. To prevent Jobs from being created for these empty reduced grid locations, return kJob_GridPosition_Invalid from Job_vtbl.convertReducedPositionToFullPosition at unoccupied positions.</p>

<h5>getPerfDescription (Advanced.)</h5>

<p>For some tests, it is sensible to also collect performance data while checking for correctness. If you collected CTPerfData, you can return that here. </p>

<h5>Init</h5>

<p>This is the vanilla object initializer for your Job class, not unlike the Obj C -init method, except that it takes a standard set of arguments. The Init function should initialize the job passed by calling the parent vtbl init functions on the object, then initializing any Job subclass member variables added at this level of inheritance to default values. </p>

<pre><code>typedef struct MyJob{
	Job parent;
	void *myField;
} MyJob;

Job *MyJob_Init( struct Job *job, const Job_GridPosition *grid, const SubTestID *list, const struct Job_vtbl *vtbl ){
   // init parent object
   job = MyJob_vtbl-&gt;parent-&gt;Init(job, grid, list, vtbl );
   if(NULL == job)
       return NULL;

   // init our fields to default value
   MyJob *j = (MyJob*) job;
   j-&gt;myField = malloc(kmyFieldSize);
   // on failure, release the object
   if( NULL == j-&gt;myField ){
       Job_release( job );
       return NULL;
   }
   // success
   return job;
}
</code></pre>

<p>If the init function fails, you should release the job object and return NULL. Caution: this means that the parent init function might return NULL. In that case, do not attempt to modify your local fields in this case, because the job object will have been destroyed by this time.</p>

<h5>print</h5>

<p>If you extend the Job base class with new data members, you’ll want to be able to print those out for later reference. The overloaded print function should call the parent print function first. Use ct_log to print. It has printf() semantics.</p>

<pre><code>typedef struct MyJob{
	Job parent;
	int myField;
} MyJob;

MyJob_print(struct Job *job){
     // call parent print routine to print out parent
     MyJob_vtbl.parent-&gt;print(job);

     // print my own data
     MyJob *j = (MyJob*)job;
     ct_log( &quot;\tmy field:    %u\n&quot;, j-&gt;myField );
}
</code></pre>

<h5>FlattenIntoBuffer</h5>

<p>If you extend the Job base class with new data members and the new fields need to be preserved whenever the Job is sent over the network or saved to disk, then you need to extend FlattenIntoBuffer to flatten the new fields too. </p>

<p>This is done by calling the parent version of the function first, then adding your data to the stream, and increment the *buffer pointer to the first byte after your data:</p>

<pre><code>typedef struct MyJob{
	Job parent;
	int myField;
} MyJob;

void MyJob_FlattenIntoBuffer( struct Job *job, void **buffer ){
   // save the super class&#39;s data
   MyJob_vtbl.parent-&gt;FlattenIntoBuffer(job, buffer);

   // now save my data
   MyJob *j = (MyJob*) job;
   // file and network byte order is traditionally big endian
   uint32_t data = htonl( j-&gt;myField );  
   // copy into stream. Destination probably misaligned,
   // so use memcpy
   memcpy( *buffer, &amp;data, sizeof(data));
   // update pointer to next free byte
   *buffer += sizeof(data);
}
</code></pre>

<h5>FlattenedSize</h5>

<p>This returns the size in bytes of your Job subclass of the flattened representation of the object created by Job_vtbl.FlattenIntoBuffer. The size includes the size of the parent class.</p>

<pre><code>typedef struct MyJob{
	Job parent;
	int myField;
} MyJob;

size_t MyJob_FlattenedSize( struct Job *job, void **buffer ){
   // Get the super class&#39;s size
   size_t size = MyJob_vtbl.parent-&gt;FlattenedSize(job);
 
   // Add my size to it
   MyJob *j = (MyJob*) job;
   return size + sizeof( j-&gt;myField );
}
</code></pre>

<h5>InitWithFlatData</h5>

<p>Job_vtbl.FlattenIntoBuffer serializes the Job subclass into a sequence of consecutive bytes for transport over the network or save to disk. This reverses the process. Always call the parent class’s version of this function before doing your part. </p>

<pre><code>typedef struct MyJob{
	Job parent;
	int myField;
} MyJob;

Job *MyJob_InitWithFlatData( struct Job *job, void **buffer, const struct Job_vtbl *vtbl ){
   // Always initialize the parent first. This may fail!!
   job = MyJob_vtbl.parent-&gt;InitWithFlatData(job, buffer, vtbl);
   if( NULL == job )
      return NULL;

   uint32_t data;
   // copy misaligned data from stream 
   memcpy( &amp;data, *buffer, sizeof(data));
   // deal with network byte order and assign to object
   MyJob *j = (MyJob*) job;
   j-&gt;myField = ntohl(data);
   // advance buffer ptr to next unused byte
   *buffer += sizeof(data);

   // on success, return job. Otherwise, release job and
   // return NULL. In this case, we can&#39;t fail, so we just
   // return the result
   return job;
}
</code></pre>

<h5>destructor</h5>

<p>Sometimes a job may reference data that needs to be released or freed. If so, override the destructor to do that.</p>

<pre><code>typedef struct MyJob{
	Job parent;
	void *myField;
} MyJob;

void MyJob_destructor( struct Job *job ){
   MyJob *j = (MyJob*) job;

   // free my data
   free( j-&gt;myField );

   // Always destroy parent data too
   Job_vtbl.parent-&gt;destructor(job);
}
</code></pre>

<p>Do not call free(job) on the job directly, however. The framework will manage that. destructor() just tears down the stuff referenced by the job subclass. </p>

<h5>InitWithParams, getParam, getParamName, getParamCount</h5>

<p>The Run Single Test Case Window in CrashTester is set up to allow you to reproduce failures locally and debug them. Double clicking a error in the main window causes the Run Single Test Case window to become populated with the information from the Job that failed. Here are two such:</p>

<figure><img src="Screen%20Shot%202014-06-17%20at%201.20.05%20PM.png" alt="Params and param names for Alpha Test" title="Fig 1"/><figcaption>Params and param names for Alpha Test</figcaption></figure>

<figure><img src="Screen%20Shot%202014-06-17%20at%201.20.10%20PM-1.png" alt="Params and param names for BoxTent Test" title="Fig 2"/><figcaption>Params and param names for BoxTent Test</figcaption></figure>

<p>As may be noted by comparing the two images, the labels are different for the NSTextBoxes at the top of each window. In fact the contents of each text box and how it is interpreted (integer, double, string) is handled by the Job type in the “Kind” popup menu. This is done through what CrashTest.framework describes as params. </p>

<p>Params are an opaque pointer (void*) to a Obj C type, roughly analogous to id and may represent an NSInteger, NSString or perhaps other objects. Since we are writing in C, normally we could not access Obj C types directly, but the framework makes available a collection of C functions which convert these to ordinary C data types, if they function pointers are non-NULL. </p>

<pre><code>#include &lt;CrashTest/CTDataFormatters.h&gt;

typedef struct CTFormatters{
	void*   (*int2Object)(int);
	void*   (*float2Object)(float);
	void*   (*double2Object)(double);
	void*   (*string2Object)(const char*);

	int     (*object2Int)(void *object);
	float   (*object2Float)(void *object);
	double  (*object2Double)(void *object);
	void    (*object2String)(const void *object, char *string, size_t maxLen );
}CTFormatters;

CTFormatters *GetCTFormatters( void );   //returns NULL on client
</code></pre>

<p>The contents of this window are configured using an array of void *param[9]. These are in order:</p>

<ol>
	<li>loops counter 0</li>
	<li>loops counter 1</li>
	<li>loops counter 2</li>
	<li>loops counter 3</li>
	<li>top left text box</li>
	<li>next text box down from top left</li>
	<li>top right text box</li>
	<li>next text box down from top right</li>
	<li>flags field </li>
</ol>

<p>Note that because you can configure the labels next to these fields, the names listed above are subject to change.</p>

<h6>getParamName</h6>

<p>This returns the text string to display in the label next to the text boxes in the Run Single Test Case window. Labels for the the loops counters are handled by the parent implementation which updates the value pointed to by param to a value in the range [0,4]. The remaining positions are therefore:</p>

<ol>
	<li>top left text box</li>
	<li>next text box down from top left</li>
	<li>top right text box</li>
	<li>next text box down from top right</li>
	<li>flags field </li>
</ol>

<p>You can name them pretty much anything you like.</p>

<pre><code>const char MyJob_getParamName( Job *job, int *param ){
 const char *result = MyJob_vtbl.parent-&gt;  
                       getParamName(job,param);
if( result )
    return result;
switch( *param ){
    case 0:    return &quot;left arm&quot;;
    case 1:    return &quot;left leg&quot;;
    case 2:    return &quot;right arm&quot;;
    case 3:    return &quot;right leg&quot;;
    case 4:    return &quot;head&quot;;
    default:   
            *param -= 5;
            return NULL;
  }
}
</code></pre>

<h6>getParam</h6>

<p>This returns the value to display in the text boxes that appear in the Run Single Test Case window. The values for the loops counters, are handled by the parent implementation which updates the value pointed to by param to a value in the range [0,4]. The remaining positions are therefore:</p>

<ol>
	<li>top left text box</li>
	<li>next text box down from top left</li>
	<li>top right text box</li>
	<li>next text box down from top right</li>
	<li>flags field </li>
</ol>

<p>The values can be strings, ints, floats or doubles.</p>

<pre><code>void *ImageTest_getParam( Job *job, int *param )
{   
 void *result = MyJob_vtbl.parent-&gt;getParam( job, param ); 

if( result )
   return result;
		
CTFormatters *f = GetCTFormatters();
if( NULL == f ){
   *param -=5;
   return NULL;
}

MyJob *test = (MyJob*) job;
switch( *param )
{
   case 0:
     return f-&gt;int2Object( test-&gt;src_height );
   case 1:
     return f-&gt;int2Object( test-&gt;src_width );
   case 2:
     return f-&gt;int2Object( test-&gt;dest_height );
   case 3:
     return f-&gt;int2Object( test-&gt;dest_width );
   case 4:
     return f-&gt;int2Object( test-&gt;flags );
   default:
     *param -= 5;
     return NULL;
}
}
</code></pre>

<h6>InitWithParams</h6>

<p>This is like the many other init statements, except that it inits the contents of the Job object using human readable parameters rather than a grid location or serialized data stream. Like others, it should call the parent implementation first and take care that the parent init function does not return NULL.</p>

<pre><code>Job* MyJob_initWithParams( struct Job *job, void ***params, const Job_GridPosition *fullGridPosition, const SubTestID *list, const struct Job_vtbl *vtbl ){
	//Check to make sure this can even be done
	Formatters *f = GetFormatters();
	if( NULL == f )
		return NULL;

// Calculate the grid position if NULL
Job_GridPosition grid;
if( NULL == fullGridPosition ){
    grid.y = f-&gt;object2Int( params[0][4] );
    grid.x = f-&gt;object2Int( params[0][5] );
    fullGridPosition = &amp;grid;
}

//Allow the parent to init itself. This may change *params.
job = Job_vtbl.parent-&gt;InitWithParams( 
           job, params, fullGridPosition, list, vtbl );
if( NULL == job )
    return job; 

//Init our local data
MyJob *test = (MyJob*) job;
if( NULL != params )
{
   test-&gt;src_height = f-&gt;object2Int( params[0][0] );
   test-&gt;src_width = f-&gt;object2Int( params[0][1] );
   test-&gt;dest_height = f-&gt;object2Int( params[0][2] );
   test-&gt;dest_width = f-&gt;object2Int( params[0][3] );
   test-&gt;flags = f-&gt;object2Int( params[0][4] );
   *params += 5;
}
else
   test-&gt;src_height = test-&gt;src_width = test-&gt;dest_height = test-&gt;dest_width = test-&gt;flags = 0;
	
   return job;
}
</code></pre>

<h6>GetParamCount</h6>

<p>The number of params needed by the object. </p>

<pre><code>int MyJob_getParamCount( Job *job )
{
  return 5 + MyJob_vtbl.parent-&gt;getParamCount( job ); 
}
</code></pre>

<h3>4)Running your .ctplugin within Xcode</h3>

<p>The easiest thing to do is add the following enviroment variable to the Xcode scheme that you use to run your plugin. This will allow you to use the plugin without having to install it in the usual search path.</p>

<figure><img src="Screen%20Shot%202014-06-26%20at%209.20.22%20PM.png"/></figure>

<h3>5)Other Stuff You’ll Need to Do</h3>

<p>CrashTest.framework does not today include any check functions to verify two results are within tolerance of one another. If your opinion of correct is bitwise identical, memcmp() is an excellent choice, and doesn’t need to be added to the framework. Otherwise, our opinion of the right shade of gray probably doesn’t match yours so we haven’t bothered. Usually, such check functions are bundled into each plugin.</p>

<h4>Test performance</h4>

<p>It is often worthwhile to run any new test under Instruments to see if the time is mostly spent testing the code or doing other stuff. You can offload expensive setup computation to the Job_vtbl.InitBuffers(). Consider setting up a reduced test grid using Job_vtbl.convertReducedPositionToFullPosition() to cut down on the number of largely redundant test cases.</p>

<h4>Stuff You Should Not Do</h4>

<p>CrashTester is a <strong>HIGH PERFORMANCE</strong> test framework. It will keep your CPU’s at 100% occupancy for as long as it takes to finish the test. It can evaluate trillions of individual function calls for correctness, which is far too much data to save to disk unless you believe your disk is likely to be faster than all of the CPU cores put together. Consider also that you will have to copy your file of reference results or checksums to each iOS device before the cluster node can be launched there. That will be painful. As a result, the use of reference output data sets to verify correctness usually isn’t practical in CrashTester. Instead, we recommend that you write a reference implementation that produces correct results (but less optimally and in a very verifiably correct fashion) and compare the framework code against the reference implementation using a check function of some kind. </p>

<h3>Types</h3>

<p>Many of the types in CrashTest.framework should be fairly straightforward to understand. However, a few would benefit from some coverage in detail.</p>

<h4>Job_vtbl</h4>

<p>A predecessor of CrashTest.framework was written nearly entirely in Objective-C. When ppc64 was introduced for OS X Tiger, it arrived without an Objective-C or C++ compiler. As one of the lucky few components required to ship on the nascent architecture before the tools were all there, we were forced to hastily rip out all the Objective-C from our test suite and replace it with C. Since we are reluctant to go through that experience again, the core of CrashTest.framework remains in C, even though it quite obviously should be in an object oriented programming language.<sup><a id="ffn5" href="#fn5" class="footnote">5</a></sup> </p>

<p>The Job_vtbl is at first glance much like the virtual function table built by a C++ compiler to implement virtual methods in a class hierarchy. It contains a list of virtual function pointers, some runtime type information and a few other odds and ends important to polymorphism. In C++, the programmer rarely interacts directly with the vtbl, so another analogy might be the Objective-C Class (objc_class) which serves a similar role.<sup><a id="ffn6" href="#fn6" class="footnote">6</a></sup> </p>

<p>At compile time, most Job_vtbls consist largely of NULL function pointers. The non-NULL entries are only those methods for which the derived class chooses to replace the parent class method. When the plugin is loaded at runtime, the framework replaces the NULL method pointers of derived classes with the method pointer of the parent classes, such that no method is NULL. The Job_vtbl.jobType is also overwritten. The rest of the Job_vtbl is not modified. </p>

<h4>JobType</h4>

<p>A portable representation of the class of an object is needed for serialization so that Job objects can be sent over the network or saved to disk and be unpacked later without losing its identity. For each process, CrashTest.framework keeps a list of pointers to all Job_vtbls it knows about. The JobType is an index into that list. </p>

<p>The value of the JobType for a particular Job subclass shall be fixed from launch to launch and across architectures so as to avoid breaking the file format or create network incompatibilities. Each plugin must register for a ReservedPluginID,<sup><a id="ffn7" href="#fn7" class="footnote">7</a></sup> which comprises some of the bits in the JobType. The rest of the bits code for the position in the CrashTestList where the Job_vtbl pointer resides. Consequently, the position of each entry in your CrashTestList must remain fixed over time. </p>

<p>If you must change the serialized representation of a class, one method of ensuring backwards file format compatibility is to mark the old class obsolete,<sup><a id="ffn8" href="#fn8" class="footnote">8</a></sup> and make a new class at a new JobType with the new behavior.</p>

<h4>CTBufferContext</h4>

<p>It is frequently the case that Job_vtbl.DoJobWithContext() requires a lot of expensive state to be set up before any testing can be done. For example, test buffers may have to be allocated and populated with test data. If the setup can be reused across many calls to Job_vtbl.DoJobWithContext(), then it is usually very advantageous to set it up once and reuse the setup across many calls to Job_vtbl.DoJobWithContext() for different jobs of the same type. This is done with the CTBufferContext.</p>

<p>When the framework detects a new Job_vtbl.DoJobWithContext() in operation, it calls Job_vtbl.InitBuffers to create a new CTBufferContext for it. This CTBufferContext is then reused repeatedly until the Job_vtbl.jobType changes. The old CTBufferContext, if any, is deleted using the CTBufferContext.free() method. </p>

<p>When writing your own Job_vtbl.InitBuffers() routine, you should make a C subclass of the BufferContex struct, by declaring a new struct type with CTBufferContext as its first element. Set the CTBufferContext.free() function to a bit of code that will tear down anything you added to the CTBufferContext and then free the context itself:</p>

<pre><code>typedef struct MyCTBufferContext{
   CTBufferContext  parent;
   void *         myData1;
   int            myData2;
}MyCTBufferContext;

CTBufferContext * MyJobType_InitBuffers( int *err ){
    MyCTBufferContext *b = malloc(sizeof(MyCTBufferContext));
    b-&gt;parent.free = MyCTBufferContext_tearDown;
    b-&gt;parent.jobType = MyJob_vtbl.jobType;

    // init private data
    b-&gt;myData1 = malloc(...);
    b-&gt;myData2 = 31;
}

static void MyCTBufferContext_tearDown( struct CTBufferContext *p){
    MyCTBufferContext *q = (MyCTBufferContext) p;
    // free my custom data
    free(q-&gt;myData1);
    // free the CTBufferContext
    free(p);
}

Job_vtbl MyJob_vtbl = {
...
  .InitBuffers = MyJobType_InitBuffers,
...
};
</code></pre>

<p>No guarantees are made about the order in which Jobs of the same class access a CTBufferContext. Reentrant access into a CTBufferContext by multiple Jobs shall not occur. </p>

<h4>Job_GridPosition and Job_GridSize</h4>

<p>All work is subdivided into individual Job objects assigned to cells within a rectangular grid. At any given time one or more of these Job objects may be running in one or more different processes. </p>

<p>The “full grid” (see Job_vtbl.fullGridSize) defines the limit of what diversity of different Jobs of the same type that may be handled without error. For example, in your CTBufferContext, you might have allocated some arrays to test any 2D array up to 1024 x 1024 in size. If the job grid is set up to test the function against a variety of array sizes, you might set the full grid dimension is (Job_GridSize){1024, 1024}. This allows you to test at any Job_GridPosition from [0,1023] in each dimension, or in other words test any 2D array size from 0 to 1023 elements in each dimension. This is the grid that is searched by the Monte Carlo test strategy.</p>

<p>Since the full grid can be impractically expensive to exhaustively test,<sup><a id="ffn9" href="#fn9" class="footnote">9</a></sup> a second smaller Job_GridSize is also defined as Job_vtbl.reducedGridSize. A mapping function is defined in Job_vtbl.convertReducedPositionToFullPosition() that converts a Job_GridPosition in the reduced grid to a position in the full grid. You might decide that your code is fully exercised by 2D arrays of size 0-16 in each dimension plus a few token large ones. In that case, perhaps 20 sizes in each dimension is good enough. The Job_vtbl.convertReducedPositionToFullPosition would then use a lookup table or other device to convert a 20x20 reduced grid to a sparse set of coordinates in the full grid. The reduced grid is the one searched by the standard test. </p>

<h4>CTException</h4>

<p>Most CrashTest.framework tests contain loops that test code over more degrees of freedom than just those represented in the search grid. (See Job_GridPosition above for a description of the grid.) Consequently, when a test encounters an error, it may find the same error each time through the loop, resulting in thousands or millions of error reports per Job. As this is impractical to manage, it is recommended that the Job_vtbl.DoJobWithContext() terminate immediately when an error occurs. </p>

<p>The standard way to do that is to throw a CTException. CTExceptions are opaque private types in CrashTest.framework. You are not expected to interact with them in any way. However, you can throw one, by calling CTThrowError():</p>

<pre><code>#include &lt;CrashTest/CTTesting.h&gt;

void CTThrowError( long ctError, long errVal, long line, const char *fileName, const char *name, const char *errStr );
</code></pre>

<p>The parameters are as follows:</p>

<ul>
	<li>ctError: A CTTestStatus from CTErrors.h</li>
	<li>errVal: an error code of your own devising to be reported</li>
	<li>line: The line number where the error was detected. </li>
	<li>fileName: The source file where the error was detected.</li>
	<li>name: A short human readable name for the thing being tested, for example the name of the function being tested.</li>
	<li>errStr: Additional human readable information about the error. This can be quite detailed. May be NULL.</li>
</ul>

<p>CTThrowError() does not return. It calls longjmp() to return to the test loop. The exception is attached to the Job, appropriate error state set on the Job and the next Job is processed. </p>

<blockquote>
<p>Since CTThrowError() does not return, there is the potential that anything allocated in Job_vtbl.DoJobWithContext (from which CTThrowError is presumably called) will leak. Moving all heap allocations to Job_vtbl.InitBuffers() is one way to simply solve this problem.</p>
</blockquote>

<h4>CTPerfData </h4>

<p>Usually it is the case that you are better off writing a separate performance test so that both the needs of the correctness test and performance test for your code can be best addressed. However, sometimes it turns out that the organization of the correctness test is well suited to collecting performance information at the same time. You may decide to collect such data in your Job_vtbl.DoJobWithContext() and export it with the job on successful completion of Job_vtbl.DoJobWithContext() as a CTPerfData object. The data will be displayed in the CrashTester.app GUI. It is frequently useful for identifying performance problems that only occur in some regions of the search grid.</p>

<h4>Job.loops</h4>

<p>Neither CrashTest.framework or CrashTester.app know what the contents of Job.loops[4] contains. The data is initialized to 0 at object creation, and faithfully carried around after that. If you change it in your Job_vtbl.DoJobWithContext() then the values will be reflected in the GUI when the job has finished executing. </p>

<p>Typically the Job.loops[4] can be used to save progress through a nested loop structure in your Job_vtbl.DoJobWithContext() so that when you replay the failure case, the replay goes straight to the loop iteration that reported the failure. However, you can do whatever you like with the Job.loops[4]. </p>

<h4>Params</h4>

<p>See section entitled “InitWithParams, getParam, …” above. </p>

<h4>SubTestID</h4>

<p>Many of our tests actually test hundreds of different functions. For example, the vImage Conversions test loops over perhaps 100 different image conversion functions. Sometimes we are interested in just one of the functions. If the test is too slow, it becomes tempting to comment out most of the Job_vtbl.DoJobWithContext() and leave just the bits necessary to test the particular function we are interested in.</p>

<p>Unfortunately, it has been much to frequently the case that the changes to the test get checked in to SVN by mistake. Then our testing fails to test all of the functions for some months until we happen to stumble upon the commented out region and fix it. This is ++ungood. </p>

<p>New for the current version of CrashTester, is basic support for dividing each test up into subtests. By default, all subtests are tested. However, the user may opt to just have some tested by toggling appropriate check boxes in the GUI or configuring options at the ct_client command line. </p>

<p>How does this work:</p>

<ul>
	<li>A list of subtests is declared in Job_vtbl.subtestNameList. This is a NULL terminated array of pointers to C strings providing the names of the subsections of your test. These should be human readable names. For example, if you are testing the functions in string.h, the list might be { “memcpy”, “memmove”, “strlen”, “memset”, NULL}. Toggling memcpy to on in the GUI, but the rest to off would signal your Job_vtbl.DoJobWithContext() to just do the memcpy tests. Each declared subtest has a SubTestID which is the index into this array at which the name of the subtest appears. The SubTestID for strlen would then be 2.</li>
	<li>The GUI scans this list after the CrashTest plugins are loaded and builds appropriate controls to allow the user to independently select which subtests to run. This information is used when new Jobs are created to set the Job.subTestList of each job.</li>
	<li>When Job_vtbl.DoJobWithContext() is called, the subtest aware implementation will look at the list of subtests encoded in Job.subTestList and skip any parts of the test that were turned off by the user. </li>
</ul>

<p>Arrays of SubTestIDs are encoded as follows:</p>

<ul>
	<li>If the pointer to the array is NULL, run all tests.</li>
	<li>If the pointer to the array is not NULL, the first item in the array is the number of elements in the array not counting the first one. This is like pascal strings, but with larger elements.</li>
	<li>Remaining entries in the array code for the SubTestIDs that are to be tested. If the number of subtests is small, you can use the SubTestID array to prepare a bitfield that encodes which test to run. Check appropriate bits in the bitfield before running each segment. Alternatively, you could organize the test into a table of function pointers and use the SubTestIDs to index the table to find what to run.</li>
</ul>

<p>The Job.subTestList storage is owned by the JobBase class. You should not attempt to modify it.</p>

<h4>CTVectorLevel</h4>

<p>We write a lot of vector code. There are frequently entirely separate functions that are called depending on which bits of various vector ISA extensions are supported on the current hardware. We need to test all of them. We don’t always have every hardware variant on hand. We use the CTVectorLevel to track what sort of hardware variant we are attempting to mimic in the test. </p>

<p>The CTVectorLevel is a bitfield that encodes which vector ISA extensions are available for use. The meaning of the bits is different on arm vs. Intel. They are defined by the feature bit mapping of _get_cpu_capabilities() in System.framework/PrivateHeaders/machine/cpu_capabilities.h. They encode for things like “This machine has AVX” or “This machine has Neon”.</p>

<p>CTVectorLevel.h provides interfaces for reading and modifying a global variable that encodes for the current vector level being tested. The current vector level will never exceed the feature set available to the machine it is running on. You can also set a software cap on vector level when initializing the global with CTInitVectorLevel(). If you don’t want a software cap, just use kCTMaxVectorLevel. The vector level may be further adjusted in response to Jobs pushed over the network from CrashTester.app which are created in response to user actions in the GUI. </p>

<p>The global vector level does not by itself turn on and off bits of hardware in the CPU. You need to add to your library the capability to respond to a vector level input and adjust its which code path is called accordingly. If you have not added this capability to your library, then the vector level has no effect. </p>

<h4>CTTestStatus</h4>

<ul>
	<li>kTestNotCompiledIn — Earlier versions of CrashTester had the option to turn off various tests. Now that we have a plugin architecture, this is no longer needed.</li>
	<li>kCorruptFloatStateError — On Intel, it is possible to leave the machine with an inoperable x87 floating point unit by using MMX and forgetting to call emms before returning. Similar things can happen when you use AVX without vzeroupper. Some tests detect when this happens and CTThrowError(kCorrupFloatStateError,…).</li>
	<li>kCrashed — A signal (SIGSEGV, SIGBUS, SIGFPE or SIGILL) was caught on the test thread. Typically, these would cause a normal application to terminate, but are reported as CTExceptions with the kCrashed error code here. </li>
	<li>kResultMismatchError — We frequently test vector code against scalar reference code. If they produce results that are too dissimilar, then we CTThrowError(kResultMismatchError,…)</li>
	<li>kScalarError — The scalar reference code returned an error instead of producing a testable result.</li>
	<li>kVectorError — The vector code returned an error instead of producing a testable result.</li>
	<li>kTestCancelled — The user hit the Cancel button</li>
	<li>kErrorRaised — An unspecified error occurred</li>
	<li>kTestSkipped — The user skipped a test grid row</li>
	<li>kJobPending — The job has been created but isn’t running anywhere yet.</li>
	<li>kJobWorking — The job is currently in Job_vtbl.DoJobWithContext()</li>
	<li>kJobDone — The job has completed Job_vtbl.DoJobWithContext() and found no errors.</li>
</ul>

<ol id="footnotes">
	<li id="fn1">The 2D segmentation gives CrashTester the ability to distribute the workload out as individual jobs to a cluster, and provides an abstraction with which to graphically represent successes and failures on a 2D progress bar. Patterns of success and failure on screen can often hint whether there is one bug, two or many. <a href="#ffn1">&#8617;</a></li>
	<li id="fn2">In the latter case, it is useful to launch a client node under the debugger on the client device. It will fork itself, but only a single copy will get the job, and you can debug it there. <a href="#ffn2">&#8617;</a></li>
	<li id="fn3">Typically this is most easily done by selecting the build products directory for a Xcode workspace. <a href="#ffn3">&#8617;</a></li>
	<li id="fn4">In addition, there is code in there to checksum the TEXT segment containing the symbol, but it is currently not used because the checksum runs into spurious failures when lldb has inserted a breakpoint in the segment.  <a href="#ffn4">&#8617;</a></li>
	<li id="fn5">The reader has perhaps sometimes wondered what the degree of improvement object oriented programming languages really have over C for object oriented programming, if it really came down to a serious go of it in C. Here you will get to find out first hand. <a href="#ffn5">&#8617;</a></li>
	<li id="fn6">Though strictly speaking, Class per se is probably more akin to JobType. Class is a pointer to the objc_class rtti info. JobType is an index into an array of pointers to Job_vtbls<em></em> <a href="#ffn6">&#8617;</a></li>
	<li id="fn7">File a bug against Accelerate/X asking for one, if you need one. <a href="#ffn7">&#8617;</a></li>
	<li id="fn8">It is probably sufficient to set Job_vtbl.publicName to NULL, and add some comments to mark the class obsolete.  <a href="#ffn8">&#8617;</a></li>
	<li id="fn9">They can easily include millions or billions of gridpoints. <a href="#ffn9">&#8617;</a></li>
</ol></body>
</html>
