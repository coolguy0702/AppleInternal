
'''
Module to parse the result bundles generated by the lte_test_runner tool

Please contact Core Darwin Test Engineering team for questions
Email: darwinlte-users@group.apple.com
Radar: libdarwintest | Lean Test Environment
'''

from __future__ import unicode_literals
from __future__ import print_function
import os
import sys
import plistlib
import shlex
import tarfile
from datetime import datetime
import time
from pipes import quote


RESULTS_FILE_PERFDATA = "file:PerfData"
RESULTS_FILE_PDJ = "file:pdj"
CONFIG_FILE_NAME = "testconfig.yaml"
CONFIG_PLIST_FILE = "Info.plist"
DIAGNOSTICS_FILE = "Diagnostics"
ATTACHMENTS_FILE = "Attachments"
LTERDOS_STRING = "LTERDOS=YES"

SUPPORTED_CONFIG_YAML_VERSIONS = [1]


def rfc3339_ts(timestamp):
    """ get rfc3339 compatible timestamp representationd of the datetime object `timestamp` """
    if not type(timestamp) is datetime:
        raise ValueError("Only datetime is support. Input type = {}".format(type(timestamp)))

    d = timestamp

    # calculation to find time zone suffix
    t = time.mktime(timestamp.timetuple())
    offset = -time.timezone
    if time.localtime(t).tm_isdst:
        offset = -time.altzone
    hours = abs(offset) // 3600
    minutes = (abs(offset) % 3600) // 60
    sign = '+'
    if offset < 0:
        sign = '-'
    timezone = '%c%02d:%02d' % (sign, hours, minutes)

    return '%04d-%02d-%02dT%02d:%02d:%02d%s' % (d.year, d.month, d.day, d.hour, d.minute, d.second, timezone)


def arc_to_test_status(arc):
    '''
    convert an ARC code to a testStatus

    A testStatus is a primitive PASS/FAIL result code. There are no other statuses.
    '''
    if arc >= 200 and arc < 300:
        return 'PASS'
    else:
        return 'FAIL'


def test_status_to_arc(testStatus):
    '''
    convert a testStatus to an ARC
    '''
    mapping = {
        'PASS': 200,
        'FAIL': 400
    }

    if testStatus in mapping:
        return mapping[testStatus]
    else:
        return 500


def remap_attached_files(bundle_path, obj):
    ''' Remap all the file: entries in dict to their full path under bundle_path '''
    remap = []
    for k, v in obj.iteritems():
        if k.startswith("file:"):
            # schedule an update to rbdata
            fpath = os.path.join(bundle_path, v)
            remap.append((k, fpath))

    # perform the file remapping
    for (key, new_path) in remap:
        obj[key] = new_path

    return obj


class TestResultBundle(object):

    def __init__(self, RBPath):
        '''
        Init. Should not be called directly. Use the classmethods
            ParseBundle
            ParseBundleDir
        instead to make parsed instances
        '''
        self.version = -1
        self.testName = ""
        self.projectName = ""
        self.workingDirectory = ""
        self.command = ""
        self.runAsRoot = False
        self.beginTime = None
        self.endTime = None
        self.testStatus = ""  # one of "PASS" or "FAIL"
        self.resultCode = -1  # any valid ARC
        self.contentLogFiles = {}
        self.perfDataFiles = {RESULTS_FILE_PERFDATA: [],
                              RESULTS_FILE_PDJ: []}
        self.RBPath = RBPath
        self.LTERDOS = False

        self.ResultData = None

    @classmethod
    def createTarFromDirectory(cls, output_filename, source_dir):
        """
        Create a tar.gz for the given source_dir at output_filename
        Arguments:
            output_filename - Path of the tar to be created
            source_dir - dir to tar

        Returns:
            True on success, False otherwise

        """
        if not os.path.exists(source_dir) or not os.path.isdir(source_dir):
            print("{} not a valid path or directory")
            return False

        try:
            with tarfile.open(output_filename, "w:gz") as tar:
                tar.add(source_dir, arcname=os.path.basename(source_dir))
        except Exception:
            return False

        return True

    def validate(self):
        '''
        Make sure that the result bundle is a valid directory before parsing it
        '''
        yaml_path = os.path.join(self.RBPath, CONFIG_FILE_NAME)
        info_path = os.path.join(self.RBPath, CONFIG_PLIST_FILE)
        if (os.path.exists(yaml_path) or os.path.exists(info_path)):
            return
        raise ValueError(
            "Path provided does not point to a valid result bundle")

    @classmethod
    def ParseBundle(cls, RBPath):
        '''
        Parse a result bundle directory.

        Arguments:
            RBPath - Path of the result bundle directory on disk

        Returns:
            An instance of TestResultBundle with the parsed information.

            Can raise the following Exceptions

            ValueError - if the path is invalid
            IOError - if the result bundle is invalid
        '''
        newRB = TestResultBundle(RBPath)
        newRB.validate()
        configfilepath = os.path.join(RBPath, CONFIG_FILE_NAME)
        configplistfilepath = os.path.join(RBPath, CONFIG_PLIST_FILE)

        try:
            if (os.path.exists(configplistfilepath)):
                # parse the plist and populate fields
                rbdata = plistlib.readPlist(configplistfilepath)

                newRB.version = rbdata.get('version', 2)
                newRB.testName = rbdata.get('test_id', newRB.testName)
                newRB.projectName = rbdata.get('Project', newRB.projectName)
                newRB.runAsRoot = rbdata.get('AsRoot', newRB.runAsRoot)
                newRB.workingDirectory = rbdata.get('WorkingDirectory', newRB.workingDirectory)
                newRB.argv = rbdata.get('Command', newRB.command)
                newRB.command = ' '.join([quote(x) for x in rbdata.get('Command', newRB.command)])
                begin_time = rbdata.get('result_started', newRB.beginTime)
                try:
                    # [0:-6] strips off the timezone offset (-07:00) - think about other ways of doing this
                    newRB.beginTime = datetime.strptime(begin_time[0:-6], "%Y-%m-%dT%H:%M:%S.%f")
                except ValueError as e:
                    print("Invalid date format for beginTime: {} - {}".format(begin_time, e))
                end_time = rbdata.get('result_finished', newRB.endTime)
                try:
                    newRB.endTime = datetime.strptime(end_time[0:-6], "%Y-%m-%dT%H:%M:%S.%f")
                except ValueError as e:
                    print("Invalid date format for beginTime: {} - {}".format(end_time, e))
                newRB.resultCode = rbdata.get('result_code', 100)
                newRB.testStatus = arc_to_test_status(newRB.resultCode)

                for k, v in rbdata.iteritems():
                    if k.upper() == 'LTERDOS':
                        # mark as False if set to 'NO'
                        newRB.LTERDOS = not str(v).lower().startswith('n')

                    if k.startswith('file:'):
                        config_name = k.replace('file:', '').strip()
                        fpath = os.path.join(RBPath, v)
                        # NOTE: fifos/symlinks/directories are not supported
                        if os.path.exists(fpath) and os.path.isfile(fpath):
                            if fpath.endswith(".pdj"):
                                newRB.perfDataFiles[config_name] = fpath
                            newRB.contentLogFiles[config_name] = fpath
                        else:
                            print("Invalid file config: {} = {}".format(k, v))

                # Remap top level attachments
                rbdata = remap_attached_files(RBPath, rbdata)

                # Remap the SubTest attachments
                if "SubTests" in rbdata:
                    for i, _ in enumerate(rbdata["SubTests"]):
                        rbdata["SubTests"][i] = remap_attached_files(RBPath, rbdata["SubTests"][i])

                # Ensure that the "ID" field is set properly - test_id is not fully honored
                if "ID" not in rbdata:
                    rbdata["ID"] = rbdata.get("test_id", "<not-set>")

                newRB.ResultData = rbdata

            else:
                with open(configfilepath) as f:
                    for line in f:
                        line_split = line.split(":", 1)
                        if line_split[0] == "version":
                            newRB.version = int(line_split[1].strip())
                            if newRB.version not in SUPPORTED_CONFIG_YAML_VERSIONS:
                                raise NotImplementedError(("This parser is not implemented for yaml version {}").format(newRB.version))  # noqa
                        elif line_split[0] == "name":
                            newRB.testName = line_split[1].strip()
                        elif line_split[0] == "project":
                            newRB.projectName = line_split[1].strip()
                        elif line_split[0] == "runAsRoot":
                            if line_split[1].lstrip() == "true\n":
                                newRB.runAsRoot = True
                        elif line_split[0] == "workingDirectory":
                            newRB.workingDirectory = line_split[1].strip()
                        elif line_split[0] == "command":
                            # NOTE: Does not handle nested quotes well
                            newRB.command = line_split[1].strip().strip('"')
                            newRB.argv = shlex.split(newRB.command)
                        elif line_split[0] == "beginTime":
                            begin_time = line_split[1].strip()
                            try:
                                newRB.beginTime = datetime.strptime(begin_time, "%Y:%m:%d %H:%M:%S.%f")
                            except ValueError as e:
                                print("Invalid date format for beginTime: {} - {}".format(begin_time, e))
                        elif line_split[0] == "endTime":
                            end_time = line_split[1].strip()
                            try:
                                newRB.endTime = datetime.strptime(end_time, "%Y:%m:%d %H:%M:%S.%f")
                            except ValueError as e:
                                print("Invalid date format for endTime: {} - {}".format(end_time, e))
                        elif line_split[0] == "testStatus":
                            newRB.testStatus = line_split[1].strip()
                            newRB.resultCode = test_status_to_arc(newRB.testStatus)
                        elif line_split[0] == "testSpecificLogs":
                            for logline in f:
                                try:
                                    logline = logline.split("- ", 1)[1].rstrip()
                                    logname = os.path.basename(logline)
                                    logpath = os.path.join(
                                        RBPath, logline)

                                    if not os.path.exists(logpath):
                                        print("{} does not exist".format(logpath))
                                        continue

                                    if os.path.isdir(logpath):
                                        tar_path = "{}.tar.gz".format(logpath)
                                        res = cls.createTarFromDirectory(
                                            tar_path, logpath)
                                        if not res:
                                            print("could not tar {}".format(logpath))
                                            continue

                                        logpath = tar_path
                                        logname = "{}.tar.gz".format(logname)

                                    if logpath.endswith("perfdata"):
                                        newRB.perfDataFiles[
                                            RESULTS_FILE_PERFDATA].append(
                                                logpath)
                                    elif logpath.endswith("pdj"):
                                        newRB.perfDataFiles[
                                            RESULTS_FILE_PDJ].append(
                                                logpath)
                                    else:
                                        newRB.contentLogFiles[logname] = logpath
                                except IndexError:
                                    break
                        else:
                            try:
                                if line.split("- ", 1)[1].rstrip() == LTERDOS_STRING:  # noqa
                                    newRB.LTERDOS = True
                            except IndexError:
                                continue

            return newRB

        except IOError:
            print("could not open .yaml file")
            raise

    def extractPerfDataPaths(self):
        '''
        Return the parsed perfDataFiles list.

        Returns:
            A dictionary with two keys, each having an array of paths as values
            RESULTS_FILE_PERFDATA - Perfdata v1 files
            RESULTS_FILE_PDJ - Perfdata v2 files
        '''
        return self.perfDataFiles

    @classmethod
    def ParseBundleDir(cls, RBDirPath):
        '''
        Parse a project directory that contains multiple result bundles

        Arguments:
            RBPath - Path of the project directory on disk which has the test
                     result bundles

        Returns:
            An array of TestResultBundle instances with the parsed information.

            Can raise the following Exceptions

            ValueError - if the path is invalid
            IOError - if the result bundle is invalid
        '''
        if not os.path.exists(RBDirPath)and not os.path.isdir(RBDirPath):
            raise ValueError("Project directory provided does not exist or is not a directory")  # noqa
        testRBarray = []
        try:
            testDirs = os.listdir(RBDirPath)
            for f in testDirs:
                fullpath = os.path.join(RBDirPath, f)
                if not os.path.isdir(fullpath):
                    print("--- This file should not be in the RB dir! --- : {}".format(f))
                    continue
                try:
                    thisRB = TestResultBundle.ParseBundle(fullpath)
                except ValueError:
                    print("Could not parse file {}".format(fullpath))
                else:
                    testRBarray.append(thisRB)
            return testRBarray
        except IOError:
            print("Could not open directory {}".format(RBDirPath))
            raise

    def extractBATSinfo(self):
        '''
        Extract the BATS specific information from the result bundle.

        Returns:
            Result dictionary in the BATS subtest format
        '''

        # If the result bundle is a version 2 RB with Info.plist - return that.
        if self.ResultData:
            return self.ResultData

        result = {}

        result["ID"] = self.testName
        result["test_id"] = self.testName
        if self.LTERDOS:
            result["LTERDOS"] = "YES"
        else:
            result["LTERDOS"] = "NO"
        if self.version >= 2:
            result["result_string"] = "ARC({})".format(self.testStatus)
            result["result_code"] = self.testStatus
        else:
            result["result_string"] = self.testStatus
            if self.testStatus == "PASS":
                result["result_code"] = 200
            else:
                result["result_code"] = 400

        # TestAutomation results are required to be in rfc3339 format
        result["result_started"] = rfc3339_ts(self.beginTime)
        result["result_finished"] = rfc3339_ts(self.endTime)

        # attach log files
        for key in self.contentLogFiles:
            rkey = "file: {}".format(key)
            result[rkey] = self.contentLogFiles[key]

        return result

    def __str__(self):
        '''
        Print the parsed information
        '''
        str1 = ("RBPath: " + self.RBPath + "\n"
                + "version: " + str(self.version) + "\n"
                + "testName: " + str(self.testName) + "\n"
                + "projectName: " + str(self.projectName) + "\n"
                + "runAsRoot: " + str(self.runAsRoot) + "\n"
                + "workingDirectory: " + str(self.workingDirectory) + "\n"
                + "command: " + str(self.command) + "\n"
                + "LTERDOS: " + str(self.LTERDOS) + "\n"
                + "testStatus: " + str(self.testStatus) + "\n"
                + "beginTime: " + str(self.beginTime) + "\n"
                + "endTime: " + str(self.endTime) + "\n"
                + "contentLogFiles:\n")
        if self.contentLogFiles:
            str1 = str1 + str(self.contentLogFiles) + "\n"

        str1 = str1 + "perfDataFiles(V1):\n"
        if self.perfDataFiles[RESULTS_FILE_PERFDATA]:
            str1 = str1 + str(self.perfDataFiles[RESULTS_FILE_PERFDATA]) + "\n"

        str1 = str1 + "perfDataFiles(V2):\n"
        if self.perfDataFiles[RESULTS_FILE_PDJ]:
            str1 = str1 + str(self.perfDataFiles[RESULTS_FILE_PDJ])

        if self.ResultData:
            str1 += "ResultData: {}\n".format(self.ResultData)

        return(str1)


# Test code only. Do not use Module directly
if __name__ == '__main__':
    try:
        RBDir = sys.argv[1]
    except IndexError:
        RBDir = "../../tests/assets/libLTE_tests/test_lte_test_result_bundle/darwintest_lte_base"  # noqa
    testRBarray = []
    testRBarray = TestResultBundle.ParseBundleDir(RBDir)
    for f in testRBarray:
        print(f)
        result = f.extractBATSinfo()
        for key in result:
            print(key + " -- " + str(result[key]))
        print("\n")
