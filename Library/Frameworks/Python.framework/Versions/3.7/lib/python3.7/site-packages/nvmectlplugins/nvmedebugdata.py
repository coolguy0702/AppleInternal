#!/usr/bin/python

import datetime

import nvmectl
import nvmectlparser
import os
from multiprocessing import Process, Queue
from collections import namedtuple


# Return an integer representing the whole data for a 128 bit SMART item, as if it will ever get there...
def get_smart_item_128(item):
    low = nvmectl.NVMeCTL_u64ArrayGet(item, 0)
    high = nvmectl.NVMeCTL_u64ArrayGet(item, 1)
    return low + (high << 64)


# Execute a get log page command, and optionally parse the data
def get_log_page(ctl, info, args):
    size_map = {nvmectl.kNVMeLogIDSMART: nvmectl.kNVMeSMARTLogDataSize,
                nvmectl.kNVMeLogIDErrorInfo: nvmectl.kNVMeErrorInfoLogDataSize}

    if args.size is None and args.log_id not in size_map:
        print("Error: Must supply size for unknown log ID. (%d)" % args.log_id)
        return 1
    if args.size is not None and args.binary_file is None:
        print("Error: Size specification requires a binary output file with --binary-file")
        return 1
    if args.binary_file is None and args.log_id != nvmectl.kNVMeLogIDSMART:
        print("Error: Must supply a file for all logs but the SMART log. (%d)" % args.log_id)
        return 1
    log_size = args.size
    if log_size is None:
        log_size = size_map[args.log_id]
    num_dwords = (log_size // 4) - 1
    buf = nvmectl.charArray(max(log_size, 4096))
    retval = ctl.GetLogPage(buf, args.log_id, num_dwords)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Get log page', r=retval)))
        return retval.fReturn

    if args.binary_file is not None:
        print("Writing %d bytes to %s" % (log_size, args.binary_file))
        status = ctl.WriteBufferToFile(buf, log_size, args.binary_file)
        if status != 0:
            print("Error: Failed writing data to file. (%s)" % (os.strerror(status)))
            return status
    elif args.log_id == nvmectl.kNVMeLogIDSMART:
        smart = ctl.bufToSMART(buf)
        result = ""
        result += "%-40s %d\n" % ("CRITICAL_WARNING", smart.CRITICAL_WARNING)
        result += "%-40s %d\n" % ("TEMPERATURE", smart.TEMPERATURE)
        result += "%-40s %d\n" % ("AVAILABLE_SPARE", smart.AVAILABLE_SPARE)
        result += "%-40s %d\n" % ("AVAILABLE_SPARE_THRESHOLD", smart.AVAILABLE_SPARE_THRESHOLD)
        result += "%-40s %d\n" % ("PERCENTAGE_USED", smart.PERCENTAGE_USED)
        result += "%-40s %d\n" % ("DATA_UNITS_READ", get_smart_item_128(smart.DATA_UNITS_READ))
        result += "%-40s %d\n" % ("DATA_UNITS_WRITTEN", get_smart_item_128(smart.DATA_UNITS_WRITTEN))
        result += "%-40s %d\n" % ("HOST_READ_COMMANDS", get_smart_item_128(smart.HOST_READ_COMMANDS))
        result += "%-40s %d\n" % ("HOST_WRITE_COMMANDS", get_smart_item_128(smart.HOST_WRITE_COMMANDS))
        result += "%-40s %d\n" % ("CONTROLLER_BUSY_TIME", get_smart_item_128(smart.CONTROLLER_BUSY_TIME))
        result += "%-40s %d\n" % ("POWER_CYCLES", get_smart_item_128(smart.POWER_CYCLES))
        result += "%-40s %d\n" % ("POWER_ON_HOURS", get_smart_item_128(smart.POWER_ON_HOURS))
        result += "%-40s %d\n" % ("UNSAFE_SHUTDOWNS", get_smart_item_128(smart.UNSAFE_SHUTDOWNS))
        result += "%-40s %d\n" % ("MEDIA_ERRORS", get_smart_item_128(smart.MEDIA_ERRORS))
        result += "%-40s %d" % ("NUM_ERROR_INFO_LOG_ENTRIES", get_smart_item_128(smart.NUM_ERROR_INFO_LOG_ENTRIES))

        print(result)

    return 0

get_log_page_parser = nvmectlparser.subparsers.add_parser("GetLogPage", help="Execute a get debug log command, and write the data to a file.")
get_log_page_parser.add_argument("-b", "--binary-file", help="Output the data as a binary to a file. Mandatory for all logs but the SMART log.")
get_log_page_parser.add_argument("-l", "--log-id", type=nvmectlparser.nonnegative, default=nvmectl.kNVMeLogIDSMART,
                                 help="The log ID to read. Defaults to the SMART log.")
get_log_page_parser.add_argument("-s", "--size", type=nvmectlparser.positive, default=None, help="The number of bytes to read. For recognized logs, defaults to the NVMe spec.")
get_log_page_parser.set_defaults(func=get_log_page)


# Execute a series of ReadDebugLog commands, up to the requested size.
def read_debug_data(ctl, info, args):
    buf = nvmectl.charArray(args.size)
    retval = ctl.ReadDebugData(buf, args.size, args.logid, *args.params)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Read debug data', r=retval)))
        return retval.fReturn

    read_size = retval.fCommandSpecificData
    if read_size == 0:
        print("Error: ReadDebugData returned with 0 bytes read.")
        return 1

    if args.file is not None:
        print("Writing %s bytes to %s" % (read_size, args.file))
        status = ctl.WriteBufferToFile(buf, read_size, args.file)
        if status != 0:
            print("Error: Failed writing data to file. (%s)" % (os.strerror(status)))
            return status
    else:
        print(buf.cast())

    return 0

read_dbg_parser = nvmectlparser.subparsers.add_parser("ReadDebugData", help="Execute ReadDebugLog commands, and write the data to a file.")
read_dbg_parser.add_argument("logid", type=nvmectlparser.nonnegative, help="The log ID to read.")
read_dbg_parser.add_argument("-f", "--file", help="The file to write the data into. Defaults to standard output.")
read_dbg_parser.add_argument("-p", "--params", metavar=("PARAM1", "PARAM2"), nargs=2, type=int, default=[0, 0], help="2 Extra parameters for the command. Default is 0, 0.")
read_dbg_parser.add_argument("-s", "--size", type=nvmectlparser.positive, default=(1 << 22), help="Maximum amount of data to retreive. Default is 4MB. Minimum is 4kB")
read_dbg_parser.set_defaults(func=read_debug_data)


# Execute a series of WriteDebugLog commands, up to the requested size.
def write_debug_data(ctl, info, args):
    if args.size is None:
        buf_size = os.path.getsize(args.input_file)
    else:
        buf_size = args.size

    buf = nvmectl.charArray(buf_size)

    num_read = ctl.ReadBufferFromFile(buf, buf_size, args.input_file)
    if num_read <= 0:
        print("Error: Failed reading data from file. (%s)" % (os.strerror(-num_read)))
        return -num_read

    print("Writing %s bytes" % num_read)

    retval = ctl.WriteDebugData(buf, num_read, args.logid, *args.params)
    print((nvmectlparser.status_str.format(r=retval)))

    return retval.fReturn

write_dbg_parser = nvmectlparser.subparsers.add_parser("WriteDebugData", help="Execute WriteDebugLog commands. Read the data from a file.")
write_dbg_parser.add_argument("logid", type=nvmectlparser.nonnegative, help="The log ID to write.")
write_dbg_parser.add_argument("input_file", help="The file to read the data from.")
write_dbg_parser.add_argument("-p", "--params", metavar=("PARAM1", "PARAM2"), nargs=2, type=int, default=[0, 0],
                              help="2 Extra parameters for the command. Default is 0, 0.")
write_dbg_parser.add_argument("-s", "--size", type=nvmectlparser.positive,
                              help="Amount of data to write. Default is the whole file")
write_dbg_parser.set_defaults(func=write_debug_data)


# Get MSP RMA data
def get_msp_rma(ctl, info, args):
    buf = nvmectl.ucharArray(args.size)
    retval = ctl.GetMSPRMA(buf.cast(), args.size, args.waynum)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Get MSP RMA', r=retval)))
        return retval.fReturn

    read_size = retval.fCommandSpecificData
    if read_size == 0:
        print("Error: ReadDebugData returned with 0 bytes read.")
        return 1

    print("Writing %s bytes to %s" % (read_size, args.file))
    status = ctl.WriteBufferToFile(buf.cast(), read_size, args.file)
    if status != 0:
        print("Error: Failed writing data to file. (%s)" % (os.strerror(status)))
        return status
    return 0

msp_rma_parser = nvmectlparser.subparsers.add_parser("GetMSPRMA", help="Get MSP RMA data.")
msp_rma_parser.add_argument("waynum", type=nvmectlparser.nonnegative, help="The way number to extract the RMA from.")
msp_rma_parser.add_argument("file", help="The file to write the data into.")
msp_rma_parser.add_argument("-s", "--size", type=nvmectlparser.positive, default=(1 << 20),
                            help="Maximum amount of data to retreive. Default is 1MB. Minimum is 4kB")
msp_rma_parser.set_defaults(func=get_msp_rma)


# Perform an MSP sweep, and write the data to a file.
def do_msp_sweep(ctl, buf, size, waynum, block, plane, wordline, slc, dsp, out_file):
    retval = ctl.GetMSPSweep(buf.cast(), size, waynum, block, plane, wordline, slc, dsp)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Get MSP sweep', r=retval)))
        return retval.fReturn

    read_size = retval.fCommandSpecificData
    if read_size == 0:
        print("Error: ReadDebugData returned with 0 bytes read.")
        return 1

    status = ctl.WriteBufferToFile(buf.cast(), read_size, out_file)
    if status != 0:
        print("Error: Failed writing data to file. (%s)" % (os.strerror(status)))
        return status

    return 0


# Get MSP sweep data
def get_msp_sweep(ctl, info, args):
    if not os.path.isdir(args.directory):
        print(("Error: {} does not exist or isn't a directory.".format(args.directory)))
        return 1

    dir_name = "sweep-{}-wn{}-b{}-p{}-{}".format(info.fSerial, args.waynum, args.block, args.plane, args.mode)
    if args.dsp:
        dir_name += "-dsp"
    dir_name += "-{}".format(datetime.datetime.now().strftime("%Y-%m-%d"))

    full_path = os.path.join(args.directory, dir_name)
    try:
        os.mkdir(full_path)
    except OSError as e:
        print(e)
        return 1

    buf = nvmectl.ucharArray(args.size)
    slc = (args.mode == 'slc')
    for wordline in range(args.start_wordline, args.start_wordline + args.num_wordlines):
        out_file = os.path.join(full_path, "swp_wl_{:03}.bin".format(wordline))
        retval = do_msp_sweep(ctl, buf, args.size, args.waynum, args.block,
                              args.plane, wordline, slc, args.dsp, out_file)
        if retval != 0:
            return retval

    print(('Sweep data written to: {}'.format(full_path)))
    return 0

msp_sweep_parser = nvmectlparser.subparsers.add_parser("GetMSPSweep", help="Perform an MSP sweep and save the results.")
msp_sweep_parser.add_argument("waynum", type=nvmectlparser.nonnegative, help="The way number to sweep.")
msp_sweep_parser.add_argument("block", type=nvmectlparser.nonnegative, help="The block to sweep.")
msp_sweep_parser.add_argument("plane", type=nvmectlparser.nonnegative, help="The plane index to sweep.")
msp_sweep_parser.add_argument("directory", help="The directory to write the sweep data into.")
msp_sweep_parser.add_argument("-m", "--mode", choices=['mlc', 'slc', 'fw_slc'], default='mlc',
                              help="The type of sweep to perform. Default is mlc.")
msp_sweep_parser.add_argument("-d", "--dsp", action="store_true", help="Use DSP while sweeping.")
msp_sweep_parser.add_argument("-w", "--start-wordline", metavar="WORDLINE", type=nvmectlparser.nonnegative, default=0,
                              help="The wordline to start the sweep at. Default is 0.")
msp_sweep_parser.add_argument("-n", "--num-wordlines", metavar="N", type=nvmectlparser.positive, default=128,
                              help="The number of wordlines to sweep. Default is 128.")
msp_sweep_parser.add_argument("-s", "--size", type=nvmectlparser.positive, default=(1 << 26),
                              help="Maximum amount of data to retrieve per wordline. Default is 64MB. Minimum is 4kB")
msp_sweep_parser.set_defaults(func=get_msp_sweep)


# Send control recipe
def send_control_recipe(ctl, info, args):
    if len(args.args[0]) > 5:
        print(("Error: Up to 5 arguments are supported. Got {} arguments.".format(len(args.args[0]))))
    if args.file is None:
        buf = None
        length = 0
    else:
        buf = nvmectlparser.file_to_buff(args.file)
        if buf is None:
            return 1
        length = os.path.getsize(args.file)

    msp_data = nvmectl.MSPDataCommand()
    msp_data.TYPE = args.opcode
    msp_data.WAY_NUM = args.die_id
    msp_data.ARG1 = args.msp_id

    control_recipe = nvmectl.MSPControlRecipe()
    control_recipe.NUM_OF_VALID_ARGS = len(args.args[0])
    for i in range(len(args.args[0])):
        setter = control_recipe.__swig_setmethods__["ARG{}".format(i)]
        setter(control_recipe, args.args[0][i])

    retval = ctl.SendMSPControlRecipe(msp_data, control_recipe, buf, length)
    print((nvmectlparser.status_str.format(r=retval)))

    return retval.fReturn

control_recipe_parser = nvmectlparser.subparsers.add_parser("SendMSPControlRecipe", help="Send an MSP control recipe.")
control_recipe_parser.add_argument("opcode", type=nvmectlparser.nonnegative, help="The recipe sub-opcode.")
control_recipe_parser.add_argument("die_id", type=nvmectlparser.nonnegative, help="The die ID for the recipe.")
control_recipe_parser.add_argument("msp_id", type=nvmectlparser.nonnegative, help="The MSP ID for the recipe.")
control_recipe_parser.add_argument("-f", "--file", help="Input file with the recipe data. Its size must be a multiple of 4096.")
control_recipe_parser.add_argument("-a", "--args", type=int, nargs="*", action="append", metavar=("ARG"),
                                   help="Arguments for the recipe. Up to 5 arguments are supported.")
control_recipe_parser.set_defaults(func=send_control_recipe)

s3_sweep_modes = {"block": 0, "wordline": 1, "page": 2}
s3_sweep_bpc = {"mlc": 0, "slc": 1, "true_slc": 2, "tlc": 3, "slc_protected": 4}
s3_max_channels = 2


# Perform S3E/S3X sweep and retrieve the data.
def get_s3_msp_sweep(ctl, info, args):
    sweep_args = nvmectl.S3SweepArgsStruct()
    sweep_args.args.PLANE = args.plane
    sweep_args.args.DIE = args.die
    sweep_args.args.BLOCK = args.block

    sweep_args.args.MODE = s3_sweep_modes[args.mode] if args.mode is not None else 0xFFFFFFFF
    sweep_args.args.PAGE_WL_START = args.page_wl_start if args.page_wl_start is not None else 0xFFFFFFFF
    sweep_args.args.PAGE_WL_END = args.page_wl_end if args.page_wl_end is not None else 0xFFFFFFFF
    sweep_args.args.HEADER = args.header if args.header is not None else 0xFFFFFFFF
    sweep_args.args.COMPRESS = args.compress if args.compress is not None else 0xFFFFFFFF
    sweep_args.args.DSP = args.dsp if args.dsp is not None else 0xFFFFFFFF
    sweep_args.args.BPC = s3_sweep_bpc[args.bpc] if args.bpc is not None else 0xFFFFFFFF
    sweep_args.args.VTH_STEP = args.vth_step if args.vth_step is not None else 0xFFFFFFFF

    sweep_args.args.RV11_MIN = args.rv11[0] if args.rv11 is not None else 0xFFFFFFFF
    sweep_args.args.RV11_MAX = args.rv11[1] if args.rv11 is not None else 0xFFFFFFFF
    sweep_args.args.RV1_MIN = args.rv1[0] if args.rv1 is not None else 0xFFFFFFFF
    sweep_args.args.RV1_MAX = args.rv1[1] if args.rv1 is not None else 0xFFFFFFFF
    sweep_args.args.RV2_MIN = args.rv2[0] if args.rv2 is not None else 0xFFFFFFFF
    sweep_args.args.RV2_MAX = args.rv2[1] if args.rv2 is not None else 0xFFFFFFFF
    sweep_args.args.RV3_MIN = args.rv3[0] if args.rv3 is not None else 0xFFFFFFFF
    sweep_args.args.RV3_MAX = args.rv3[1] if args.rv3 is not None else 0xFFFFFFFF
    sweep_args.args.RV4_MIN = args.rv4[0] if args.rv4 is not None else 0xFFFFFFFF
    sweep_args.args.RV4_MAX = args.rv4[1] if args.rv4 is not None else 0xFFFFFFFF
    sweep_args.args.RV5_MIN = args.rv5[0] if args.rv5 is not None else 0xFFFFFFFF
    sweep_args.args.RV5_MAX = args.rv5[1] if args.rv5 is not None else 0xFFFFFFFF
    sweep_args.args.RV6_MIN = args.rv6[0] if args.rv6 is not None else 0xFFFFFFFF
    sweep_args.args.RV6_MAX = args.rv6[1] if args.rv6 is not None else 0xFFFFFFFF
    sweep_args.args.RV7_MIN = args.rv7[0] if args.rv7 is not None else 0xFFFFFFFF
    sweep_args.args.RV7_MAX = args.rv7[1] if args.rv7 is not None else 0xFFFFFFFF

    if args.verbose:
        for name, getter in sorted(sweep_args.args.__swig_getmethods__.items()):
            print(("{:<30}{:#x}".format(name, getter(sweep_args.args))))

    buf = nvmectl.charArray(args.max_size)
    retval = ctl.GetS3MSPSweep(args.msp * s3_max_channels + args.channel, sweep_args, buf, args.max_size)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Get S3 MSP sweep', r=retval)))
        return retval.fReturn

    num_read = retval.fCommandSpecificData
    if num_read == 0:
        print("Error: ReadDebugData returned with 0 bytes read.")
        return 1
    if num_read >= args.max_size:
        print("Warning: Maximum data size was reached. Sweep results may be incomplete.")

    print("Writing %s bytes to %s" % (num_read, args.file))
    status = ctl.WriteBufferToFile(buf, num_read, args.file)
    if status != 0:
        print("Error: Failed writing data to file. (%s)" % (os.strerror(status)))
        return status

    return 0

s3_msp_sweep_parser = nvmectlparser.subparsers.add_parser("GetS3MSPSweep", help="Perform an S3E/S3X MSP sweep and save the results.")
s3_msp_sweep_parser.add_argument("-m", "--msp", required=True, type=int, choices=list(range(4)), help="MSP index.")
s3_msp_sweep_parser.add_argument("-c", "--channel", required=True, type=int, choices=list(range(s3_max_channels)), help="Channel index.")
s3_msp_sweep_parser.add_argument("-p", "--plane", required=True, type=int, choices=list(range(4)), help="Plane index.")
s3_msp_sweep_parser.add_argument("-d", "--die", required=True, type=nvmectlparser.int_range(0, 15), help="NAND die index.")
s3_msp_sweep_parser.add_argument("-b", "--block", required=True, type=nvmectlparser.int_range(0, 5000), help="Block index.")
s3_msp_sweep_parser.add_argument("-f", "--file", required=True, help="File to write the sweep data to.")
s3_msp_sweep_parser.add_argument("--max-size", type=nvmectlparser.positive, default=(1 << 28),
                                 help="Maximum amount of sweep data to retrieve (in bytes). Default is 256MB. Minimum is 4kB.")
s3_msp_sweep_parser.add_argument("--mode", choices=list(s3_sweep_modes.keys()), help="Sweep mode.")
s3_msp_sweep_parser.add_argument("--page-wl-start", metavar="WORDLINE", type=nvmectlparser.int_range(0, 511), help="First wordline to sweep.")
s3_msp_sweep_parser.add_argument("--page-wl-end", metavar="WORDLINE", type=nvmectlparser.int_range(0, 511), help="Last wordline to sweep.")
s3_msp_sweep_parser.add_argument("--header", dest="header", action="store_true", help="Add a header to the sweep data.")
s3_msp_sweep_parser.add_argument("--no-header", dest="header", action="store_false", help="Don't add a header to the sweep data.")
s3_msp_sweep_parser.set_defaults(header=None)
s3_msp_sweep_parser.add_argument("--compress", dest="compress", action="store_true", help="Compress the sweep data.")
s3_msp_sweep_parser.add_argument("--no-compress", dest="compress", action="store_false", help="Don't compress the sweep data.")
s3_msp_sweep_parser.set_defaults(compress=None)
s3_msp_sweep_parser.add_argument("--dsp", dest="dsp", action="store_true", help="Use DSP while sweeping.")
s3_msp_sweep_parser.add_argument("--no-dsp", dest="dsp", action="store_false", help="Don't use DSP while sweeping.")
s3_msp_sweep_parser.set_defaults(dsp=None)
s3_msp_sweep_parser.add_argument("--bpc", choices=list(s3_sweep_bpc.keys()), help="Number of bits per cell to use in the sweep.")
s3_msp_sweep_parser.add_argument("--vth-step", type=nvmectlparser.int_range(0, 15), help="Voltage threshold step.")
s3_msp_sweep_parser.set_defaults(func=get_s3_msp_sweep)

for i in [1, 2, 3, 4, 5, 6, 7, 11]:
    s3_msp_sweep_parser.add_argument("--rv{}".format(i), metavar=("MIN", "MAX"), nargs=2,
                                     type=nvmectlparser.int_range(0, 255),
                                     help="Minimum and maximum values for RV{}.".format(i))


def get_ans2_seed(ctl, info, args):
    seed = ctl.GetANS2MSPSeed(args.msp_index)

    if (seed == 0):
        print("Error: Failed obtaining MSP seed.")
        return 1

    print(("{:016X}".format(seed)))
    return 0


def write_msp_seed(ctl, dir, msp_index):
    seed = ctl.GetANS2MSPSeed(msp_index)

    if (seed == 0):
        print("Error: Failed obtaining MSP seed.")
        return False

    file_name = os.path.join(dir, "seed.txt")
    with open(file_name, "w") as fd:
        fd.write("{:016X}\n".format(seed))
    return True

msp_seed_parser = nvmectlparser.subparsers.add_parser("GetANS2MSPSeed", help="Get MSP seed from ANS2.")
msp_seed_parser.add_argument("msp_index", type=nvmectlparser.int_range(0, 8), help="MSP index.")
msp_seed_parser.set_defaults(func=get_ans2_seed)


ans2_sweep_bpc = {"mlc_tlc": 0, "slc": 1, "fw_slc": 2}

# Perform ANS2 sweep on a single wordline.
def do_ans2_sweep(ctl, info, args, sweep_params, output_file, max_size, wordline):

    sweep_params.PARAMS.WORDLINE = wordline

    buf = nvmectl.charArray(max_size)
    retval = ctl.GetANS2Sweep(sweep_params, buf, max_size)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Get ANS2 sweep', r=retval)))
        return retval.fReturn

    num_read = retval.fCommandSpecificData
    if num_read == 0:
        print("Error: ReadDebugData returned with 0 bytes read.")
        return 1
    if num_read >= max_size:
        print("Warning: Maximum data size was reached. Sweep results may be incomplete.")

    print("Writing %s bytes to %s" % (num_read, output_file))
    status = ctl.WriteBufferToFile(buf, num_read, output_file)
    if status != 0:
        print("Error: Failed writing data to file. (%s)" % (os.strerror(status)))
        return status

    return 0


# Perform ANS2 sweep.
def get_ans2_sweep(ctl, info, args):
    sweep_params = nvmectl.ANS2SweepParamsStruct()

    sweep_params.PARAMS.MSP = args.msp
    sweep_params.PARAMS.CHANNEL = args.channel
    sweep_params.PARAMS.DIE = args.die
    sweep_params.PARAMS.PLANE = args.plane
    sweep_params.PARAMS.BLOCK = args.block
    sweep_params.PARAMS.BPC = ans2_sweep_bpc[args.bpc]
    sweep_params.PARAMS.VTH_STEP = args.vth_step
    sweep_params.PARAMS.IS_DSP = args.dsp
    sweep_params.PARAMS.IS_TO_COMPRESS = args.compress
    sweep_params.PARAMS.IS_TO_ADD_HEADER = args.header

    if args.verbose:
        for name, getter in sorted(sweep_params.PARAMS.__swig_getmethods__.items()):
            print(("{:<30}{}".format(name, getter(sweep_params.PARAMS))))

    dir_name = "sweep-{}-m{}-c{}-d{}-p{}-b{}-{}".format(info.fSerial, args.msp,
                                                        args.channel, args.die,
                                                        args.plane, args.block,
                                                        args.bpc)
    full_path = os.path.join(args.output_dir, dir_name)
    try:
        os.mkdir(full_path)
    except OSError as e:
        print(e)
        return 1
    print(("output directory: {}".format(full_path)))

    if (not write_msp_seed(ctl, full_path, args.msp)):
        return 1

    sweep_format = 'Sweep_Wordline_{}.bin'
    if args.wordline is None:
        geom = get_nand_geom(ctl)
        if geom is None:
            return 1
        print(("Sweeping {} wordlines...".format(geom.GEOM.PAGES_PER_BLOCK_SLC)))
        for wordline in range(geom.GEOM.PAGES_PER_BLOCK_SLC):
            file_name = os.path.join(full_path, sweep_format.format(wordline))
            retval = do_ans2_sweep(ctl, info, args, sweep_params, file_name, args.max_size, wordline)
            if retval:
                return retval
    else:
        file_name = os.path.join(full_path, sweep_format.format(args.wordline))
        return do_ans2_sweep(ctl, info, args, sweep_params, file_name, args.max_size, args.wordline)


ans2_sweep_parser = nvmectlparser.subparsers.add_parser("GetANS2Sweep", help="Perform an ANS2 MSP sweep and save the results.")
ans2_sweep_parser.add_argument("-m", "--msp", required=True, type=nvmectlparser.int_range(0, 8), help="MSP index.")
ans2_sweep_parser.add_argument("-c", "--channel", required=True, type=int, choices=list(range(8)), help="Channel index.")
ans2_sweep_parser.add_argument("-d", "--die", required=True, type=nvmectlparser.int_range(0, 15), help="NAND die index.")
ans2_sweep_parser.add_argument("-p", "--plane", required=True, type=int, choices=list(range(4)), help="Plane index.")
ans2_sweep_parser.add_argument("-b", "--block", required=True, type=nvmectlparser.int_range(0, 5000), help="Block index.")

ans2_sweep_parser.add_argument("--wordline", metavar="WORDLINE", type=nvmectlparser.nonnegative,
                               help="Specify a single wordline to sweep, instead of sweeping all of them.")
ans2_sweep_parser.add_argument("--bpc", choices=list(ans2_sweep_bpc.keys()), default="mlc_tlc", help="Number of bits per cell to use in the sweep.")
ans2_sweep_parser.add_argument("--vth-step", type=nvmectlparser.int_range(0, 15), default=1, help="Voltage threshold step.")

ans2_sweep_parser.add_argument("--dsp", dest="dsp", action="store_true", help="Use DSP while sweeping.")
ans2_sweep_parser.add_argument("--no-dsp", dest="dsp", action="store_false", help="Don't use DSP while sweeping. (Default)")
ans2_sweep_parser.set_defaults(dsp=False)

ans2_sweep_parser.add_argument("--compress", dest="compress", action="store_true", help="Compress the sweep data. (Default)")
ans2_sweep_parser.add_argument("--no-compress", dest="compress", action="store_false", help="Don't compress the sweep data.")
ans2_sweep_parser.set_defaults(compress=True)

ans2_sweep_parser.add_argument("--header", dest="header", action="store_true", help="Add a header to the sweep data.")
ans2_sweep_parser.add_argument("--no-header", dest="header", action="store_false", help="Don't add a header to the sweep data. (Default)")
ans2_sweep_parser.set_defaults(header=False)

ans2_sweep_parser.add_argument("-o", "--output-dir", required=True, help="Directory to write sweep data into.")
ans2_sweep_parser.add_argument("--max-size", type=nvmectlparser.positive, default=(1 << 24),
                               help="Maximum amount of sweep data to retrieve on each sweep. Default is 16MB. Minimum is 4kB.")

ans2_sweep_parser.set_defaults(func=get_ans2_sweep)


# Get field counters via NVMeSMARTLib
def get_field_counters(ctl, info, args):
    data = nvmectl.S1X2PlaneFieldCounters()
    status = nvmectl.NVMeCTL_GetFieldCounters(info.fBSDName, data)
    if status != 0:
        print("Error: Get field counters command failed. status=0x%x" % status)
        return status

    if args.file is None:
        # Iterate over all the counters and print them.
        for name, getter in sorted(data.ALGO_COUNTERS.__swig_getmethods__.items()):
            print(('{:<50}{}'.format(name, getter(data.ALGO_COUNTERS))))
    else:
        write_size = nvmectl.kNVMeFieldCountersNumBlocks * 4096;
        print("Writing %s bytes to %s" % (write_size, args.file))
        status = ctl.WriteBufferToFile(data, write_size, args.file)
        if status != 0:
            print("Error: Failed writing data to file. (%s)" % os.strerror(status))
            return status

    return 0

field_counters_parser = nvmectlparser.subparsers.add_parser("GetFieldCounters", help="Get field counters.")
field_counters_parser.add_argument("-f", "--file", help="Write the data as a binary blob to the specified file.")
field_counters_parser.set_defaults(func=get_field_counters)


# Get The FE parameters.
def get_fe_params(ctl, info, args):
    params = nvmectl.FEParamsStruct()
    retval = ctl.GetFEParams(params, 0)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Get FE params', r=retval)))
        return retval.fReturn

    print(('{:<40}{:<15}{:<15}{:<15}'.format("PARAM", "CURRENT", "MINIMUM", "MAXIMUM")))
    for name, getter in sorted(params.params.__swig_getmethods__.items()):
        param = getter(params.params)
        print(('{:<40}{:<#15x}{:<#15x}{:<#15x}'.format(name, param.CURRENT, param.MINIMUM, param.MAXIMUM)))


get_fe_params_parser = nvmectlparser.subparsers.add_parser("GetFEParams", help="Get FE parameters.")
get_fe_params_parser.set_defaults(func=get_fe_params)


# Set an FE parameter.
def set_fe_param(ctl, info, args):
    params = nvmectl.FEParamsStruct()
    retval = ctl.GetFEParams(params, 0)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Get FE params', r=retval)))
        return retval.fReturn

    param = params.params.__swig_getmethods__[args.param](params.params)
    if args.value < param.MINIMUM or args.value > param.MAXIMUM:
        print(("Error: value for {} must be between {p.MINIMUM:#x}-{p.MAXIMUM:#x}.".format(args.param, p=param)))

    param.CURRENT = args.value
    retval = ctl.SetFEParams(params, 0)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Set FE params', r=retval)))
        return retval.fReturn

    if not args.reinit:
        print("A controller Shutdown/Init cycle is required to"
              "activate the setting. (except for STATUS_RETURN_CODE)")
        return 0

    retval = ctl.ShutdownController(nvmectl.kNVMeShutdownNormal)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Shutdown controller', r=retval)))
        return retval.fReturn
    retval = ctl.InitController()
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Init controller', r=retval)))
        return retval.fReturn

    print("New param value is activated")
    return 0

set_fe_param_parser = nvmectlparser.subparsers.add_parser("SetFEParam", help="Set an FE parameter.")
set_fe_param_parser.add_argument("param", choices=sorted(nvmectl.FEParams.__swig_setmethods__.keys()),
                                 help="The FE parameter to set.")
set_fe_param_parser.add_argument("value", type=int, help="The value to set.")
set_fe_param_parser.add_argument("-r", "--reinit", action="store_true",
                                 help="Perform a shutdown/init cycle to activate the new setting."
                                 "Not needed for the STATUS_RETURN_CODE param.")
set_fe_param_parser.set_defaults(func=set_fe_param)


def wait_bonfire_completion(serial, q):
    ctl = nvmectl.NVMeCTL(serial, 0)
    print('Sending async event request.')
    ret = ctl.AsyncEventRequest()
    q.put([ret.fReturn, ret.fNVMeStatus, ret.fCommandSpecificData, ret.fExecutionTime])


def do_bonfire_test(ctl, info, args):
    # Send an async event request using a subprocess.
    q = Queue()
    p = Process(target=wait_bonfire_completion, args=(info.fSerial, q,))
    p.start()

    # Start the bonfire test.
    buf = nvmectl.charArray(args.size)
    num_dwords = (args.size // 4) - 1

    ret = ctl.BonfireTest(buf, num_dwords)
    if ret.fReturn != 0 or ret.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Bonfire', r=ret)))
        # Generate a bogus async event, just so we don't hang.
        ctl.CLIWrite("\ngo fe\nset_async_event 7\n")
        return ret.fReturn

    # Wait for the results.
    ret = q.get()
    print("status=0x%x NVMeStatus=0x%x dword0=0x%x time=%d" % (ret[0], ret[1], ret[2], ret[3]))
    p.join()

    # Write the result to the file.
    status = ctl.WriteBufferToFile(buf, args.size, args.file)
    if status != 0:
        print("Error: Failed writing data to file. (%s)" % (os.strerror(status)))
        return status

    return 0

bonfire_parser = nvmectlparser.subparsers.add_parser("BonfireTest", help="Execute a bonfire test.")
bonfire_parser.add_argument("file", help="The file to write the results into.")
bonfire_parser.add_argument("-s", "--size", type=nvmectlparser.positive, default=(1 << 20),
                            help="Expected result size in bytes. Deafult is 1MB")
bonfire_parser.set_defaults(func=do_bonfire_test)


# Get a random challenge buffer.
def get_random_challenge(ctl, info, args):
    buf = nvmectl.intArray(nvmectl.kNVMeChallengeNumDwords)
    ctl.GetRandomChallenge(buf.cast())

    status = ctl.WriteBufferToFile(buf.cast(), nvmectl.kNVMeChallengeNumDwords * 4, args.output_file)
    if status != 0:
        print("Error: Failed writing data to file. (%s)" % (os.strerror(status)))
        return status

    return 0

get_random_challenge_parser = nvmectlparser.subparsers.add_parser("GetRandomChallenge", help="Get a random challenge buffer for firmware debug unlocking.")
get_random_challenge_parser.add_argument("output_file", help="The file to write the challeng buffer to.")
get_random_challenge_parser.set_defaults(func=get_random_challenge)


tunnel_types = {"nand": 0, "core": 1}


# Execute a tunnel command.
def tunnel(ctl, info, args):
    options_buf = None
    if args.options_file is not None:
        options_buf = nvmectlparser.file_to_buff(args.options_file)
        if options_buf is None:
            return 1
        if os.path.getsize(args.options_file) != 80:
                print("Error: Invalid size for options file. Required size: 80 bytes.")
                return 1

    if args.input_file is None:
        if args.output_file is None:
            buf = None
            length = 0
        else:
            if args.size is None:
                print("Error: --size is required without --input-file")
                return 1
            buf = nvmectl.charArray(args.size)
            length = args.size
    else:
        buf = nvmectlparser.file_to_buff(args.input_file)
        length = os.path.getsize(args.input_file)
        if args.size is not None:
            if args.size > length:
                print("Error: Requested size is larger than input file.")
                return 1
            length = args.size

    retval = ctl.Tunnel(tunnel_types[args.type], args.opcode, options_buf, buf, length)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Tunnel', r=retval)))
        return 1

    if args.options_file is not None:
        status = ctl.WriteBufferToFile(options_buf, 80, args.options_file)
        if status != 0:
            print("Error: Failed writing data to options file. (%s)" % (os.strerror(status)))
            return status

    if args.output_file is not None:
        status = ctl.WriteBufferToFile(buf, length, args.output_file)
        if status != 0:
            print("Error: Failed writing data to file. (%s)" % (os.strerror(status)))
            return status

    print((nvmectlparser.status_str.format(r=retval)))
    return retval.fReturn

tunnel_parser = nvmectlparser.subparsers.add_parser("Tunnel", help="Execute a tunnel command.")
tunnel_parser.add_argument("type", choices=list(tunnel_types.keys()), help="The tunnel type.")
tunnel_parser.add_argument("opcode", type=nvmectlparser.nonnegative, help="The tunnel opcode.")
tunnel_parser.add_argument("-a", "--options-file", help="The options file. Must be of size 80 bytes.")
tunnel_parser.add_argument("-i", "--input-file", help="input buffer for the tunnel command.")
tunnel_parser.add_argument("-o", "--output-file", help="The file to write the modified buffer to.")
tunnel_parser.add_argument("-s", "--size", type=nvmectlparser.nonnegative,
                           help="The size of the buffer to read/write. Default: input file size.")
tunnel_parser.set_defaults(func=tunnel)


# Get a random challenge buffer.
def debug_unlock(ctl, info, args):
    buf = nvmectl.intArray(nvmectl.kNVMeChallengeSignatureNumDwords)
    read_size = nvmectl.kNVMeChallengeSignatureNumDwords * 4

    try:
        if os.path.getsize(args.signature_file) != read_size:
            print(("Error: Signature file is required to be exactly {} bytes long.".format(read_size)))
            return 1
    except OSError as e:
        print(e)
        return 1

    num_read = ctl.ReadBufferFromFile(buf.cast(), read_size, args.signature_file)
    if num_read < 0:
        print(("Error: Failed reading data from file. {}".format(os.strerror(-num_read))))
        return -num_read
    elif num_read < read_size:
        print("Error reading from signature file.")
        return 1

    ctl.DebugUnlock(buf.cast())

    return 0

debug_unlock_parser = nvmectlparser.subparsers.add_parser("DebugUnlock", help="Unlock firmware debug capabilities.")
debug_unlock_parser.add_argument("signature_file", help="The signature file to unlock with. Must be exactly 256 bytes.")
debug_unlock_parser.set_defaults(func=debug_unlock)


# Execute a debug service read command.
def debug_service_read(ctl, info, args):
    retval = ctl.DebugServiceRead(args.address)
    print((nvmectlparser.status_str.format(r=retval)))

    return retval.fReturn

debug_service_read_parser = nvmectlparser.subparsers.add_parser("DebugServiceRead", help="Execute a debug service read command.")
debug_service_read_parser.add_argument("address", type=nvmectlparser.nonnegative, help="The address to read from.")
debug_service_read_parser.set_defaults(func=debug_service_read)


# Execute a debug service write command.
def debug_service_write(ctl, info, args):
    retval = ctl.DebugServiceWrite(args.address, args.integer)
    print((nvmectlparser.status_str.format(r=retval)))

    return retval.fReturn

debug_service_write_parser = nvmectlparser.subparsers.add_parser("DebugServiceWrite", help="Execute a debug service write command.")
debug_service_write_parser.add_argument("address", type=nvmectlparser.nonnegative, help="The address to write to.")
debug_service_write_parser.add_argument("integer", type=nvmectlparser.nonnegative, help="The integer to write. Must be non-negative.")
debug_service_write_parser.set_defaults(func=debug_service_write)


def get_counter_name(counter_id):
    dictionary = {
        1: 'SMART_PERCENTAGE_USED',
        2: 'SMART_PERCENTAGE_USED_NORMALIZED',
        3: 'SMART_DATA_UNITS_READ',
        4: 'SMART_DATA_UNITS_WRITTEN',
        5: 'SMART_HOST_READ_COMMANDS',
        6: 'SMART_HOST_WRITE_COMMANDS',
        7: 'SMART_POWER_CYCLES',
        8: 'SMART_UNSAFE_SHUTDOWNS',
        9: 'SMART_MEDIA_ERRORS',
        10: 'SMART_CRITICAL_WARNINGS',
        11: 'SMART_TEMPERATURE',
        12: 'SMART_AVAILABLE_SPARE',
        13: 'SMART_AVAILABLE_SPARE_TH',
        14: 'SMART_POWER_ON_HOURS',
        101: 'ERASE_ERRORS',
        102: 'TOTAL_READ_ERRORS',
        103: 'HOST_READ_ERRORS',
        104: 'PROGRAM_DST_ERRORS',
        105: 'COPY_SRC_ERRORS',
        106: 'COPY_DST_ERRORS',
        107: 'INTERNAL_READ_ERRORS',
        108: 'RAID_LBA_MISMATCH_ERROR',
        109: 'ERR_STATS_CRC_READ_FAIL',
        110: 'ERR_RD_CRC_READ_FAIL',
        111: 'ERR_BLOG_CRC_READ_FAIL',
        112: 'ERR_PARITY_CRC_READ_FAIL',
        113: 'ERR_CLOG_CRC_READ_FAIL',
        114: 'ERR_BLANK_CRC_READ_FAIL',
        115: 'ERR_IOLOG_CRC_READ_FAIL',
        116: 'ERR_GC_CRC_READ_FAIL',
        117: 'ASSERT_HISTORY',
        201: 'THRESHOLD_UPDATES',
        301: 'HOST_FLUSHES',
        302: 'INTERNAL_FLUSHES',
        303: 'HOST_FENCES',
        401: 'RAID_RECONSTRUCTION_SUCCEEDED',
        402: 'RAID_RECONSTRUCTION_FAILED',
        403: 'PARITION_BANDS',
        404: 'RAID_PMX_PAGES_PER_BAND',
        405: 'NUM_BANDS',
        501: 'COPIED_BLOCKS_DUE_TO_RD',
        502: 'COPIED_BLOCKS_DUE_TO_SWL',
        601: 'TRIM_REQUESTS',
        602: 'TOTAL_4K_SECTORS_TRIMMED',
        701: 'SLEEP_REQUESTS',
        702: 'BOOT_FROM_DDR',
        703: 'S3_SLEEP_REQUESTS',
        704: 'S3_CLOG_DOUBLE_UNC',
        800: 'CLOG_READ_BULK_FAILED',
        801: 'CLOG_PROGRAMS',
        802: 'CLOG_PROGRAMS_FAILED',
        803: 'CLOG_READ_FAILED',
        804: 'CLOG_READ_ERASED_PAGE',
        805: 'ERR_INJ_USER_READ_FAIL',
        806: 'ERR_INJ_BLOG_READ_FAIL',
        807: 'ERR_INJ_RD_READ_FAIL',
        808: 'ERR_INJ_CLOG_READ_FAIL',
        809: 'ERR_INJ_STATS_READ_FAIL',
        810: 'ERR_INJ_UTIL_READ_FAIL',
        811: 'ERR_INJ_IOLOG_READ_FAIL',
        812: 'ERR_INJ_IND_READ_FAIL',
        813: 'RAID_RECONSTRUCT_SUCCESS_INTERNAL',
        814: 'RAID_RECONSTRUCT_FAILED_INTERNAL',
        815: 'RAID_RECONSTRUCT_SUCCESS_HOST',
        816: 'RAID_RECONSTRUCT_FAILED_HOST',
        817: 'ABORTSKIP_ABANDON_FLOW_AFTER_POWERUP',
        818: 'ABORTSKIP_REBUILD_DURING_PROGRAM',
        819: 'ABORTSKIP_PROGRAM_ERROR',
        820: 'ABORTSKIP_READ_ERROR_OPEN_BAND',
        821: 'ABORTSKIP_FAILED_REBUILDING_PARITY',
        822: 'ABORTPAD_OPEN_REFRESH_BAND',
        823: 'ABORTPAD_CLOSE_BANDS',
        824: 'ABORTPAD_SET_PHOTO',
        825: 'ABORTPAD_GC_NO_SOURCE',
        826: 'ABORTPAD_FORMAT',
        901: 'FE_LINK_DOWN',
        902: 'FE_LINK_UP',
        903: 'FE_CC_DISABLE',
        904: 'FE_CC_ENABLE',
        905: 'FE_VOTE_SLEEP',
        906: 'FE_WAKEUP',
        1001: 'SMART_GROWN_BAD_BLOCKS_PER_DIP',
        1002: 'TOTAL_ERRORS_PER_DIP',
        1003: 'CYCLES_MIN',
        1004: 'CYCLES_MAX',
        1005: 'CYCLES_AVG',
        1006: 'FACTORY_BAD_BLOCKS',
        1007: 'AVERAGE_HOLES',
        1008: 'WRITE_AMP',
        1009: 'BAND_CYCLES_MIN',
        1010: 'BAND_CYCLES_MAX',
        1011: 'LOGICAL_DISK_OCCUPIED_PROMILES',
        1012: 'HOST_WRITES',
        1013: 'NAND_WRITES',
        1862: 'RXBURN_NAND_WRITES',
        1014: 'NUM_BANDS_REFRESHED_FOR_AGE_PER_TIER',
        1015: 'NUM_BANDS_PADDED_FOR_AGE',
        1016: 'NUM_REFRESH_ON_CLOCK_LOSS',
        1017: 'NUM_REFRESH_ON_ERR_NAND_REFRESH',
        1018: 'NUM_BG_REFRESH_MOVES',
        1019: 'NUM_BG_PADDING_MOVES',
        1020: 'NUM_BG_ABORT_PADS',
        1021: 'MIN_ERASES_UTIL',
        1022: 'MAX_ERASES_UTIL',
        1023: 'AVG_ERASES_UTIL',
        1024: 'MIN_ERASES_UTIL_SLOT',
        1025: 'MAX_ERASES_UTIL_SLOT',
        1026: 'NUM_UTIL_00_REFRESH',
        1027: 'NUM_UTIL_00_NOT_FOUND',
        1040: 'SLC_CYCLES_MIN',
        1041: 'SLC_CYCLES_MAX',
        1042: 'SLC_CYCLES_AVG',
        1046: 'SLC_BAND_CYCLES_MIN',
        1047: 'SLC_BAND_CYCLES_MAX',
        1048: 'SLC_PERCENT_USAGE',
        1049: 'MLC_PERCENT_USAGE',
        1050: 'HOST_WRITE_DYNAMIC',
        1051: 'HOST_WRITE_STATIC',
        1052: 'HOST_WRITE_META',
        1053: 'HOST_WRITE_PHOTO',
        1054: 'HOST_PASSIVE_IO',
        1055: 'IND_POOL_FREE',
        1056: 'IND_POOL_SIZE',
        1057: 'IND_POOL_FREE_DIST',
        1058: 'IND_POOL_USED_DIST',
        1059: 'IND_POOL_STATS',
        1060: 'IND_MEM_STATS',
        1861: 'IND_DEC_ECC',
        1897: 'IND_BO_RECOVERIES',
        1101: 'CURRENT_TEMPERATURE',
        1102: 'MINIMUM_TEMPERATURE',
        1103: 'MAXIMUM_TEMPERATURE',
        1105: 'CURRENT_ODTS',
        1106: 'MAXIMUM_ODTS',
        1107: 'LAST_CALIBRATION_TEMPERATURE',
        1108: 'MINIMUM_CALIBRATION_TEMPERATURE',
        1109: 'MAXIMUM_CALIBRATION_TEMPERATURE',
        1110: 'CALIBRATION_COUNTER',
        1201: 'IDLE_CLOCK_GATED_ENTRY',
        1202: 'IDLE_CLOCK_GATED_EXIT',
        1203: 'IDLE_POWER_GATED_ENTRY',
        1204: 'WARM_BOOT_COUNTER',
        1205: 'IDLE_POWER_GATED_INTERRUPTED',
        1206: 'WARM_BOOT_DURATION',
        1207: 'IDLE_CLOCK_GATED_ENTRY_L1_1',
        1208: 'IDLE_POWER_GATED_ENTRY_L1_2',
        1209: 'BOOT_DURATION',
        1210: 'SYS_INIT_DURATION',
        1211: 'TOTAL_BOOT_DURATION',
        1212: 'LAST_BOOT_TYPE',
        1213: 'READY_TO_OPEN_DURATION',
        1214: 'MAXIMUM_WARM_BOOT_DURATION',
        1215: 'LAST_BOOT_POWER_HIGH_OR_LOW',
        1216: 'LAST_BOOT_COLD_OR_WARM',
        1217: 'NAND_DISCOVERY_DURATION',
        1218: 'CORE_CC_ENABLE_DURATION',
        1219: 'CORE_OPEN_DURATION',
        1220: 'CORE_WRITABLE_DURATION',
        1221: 'CORE_CLOG_LOAD_DURATION',
        1241: 'L12_TO_WFI_MIN_DURATION',
        1242: 'L12_TO_WFI_MAX_DURATION',
        1240: 'ACCUMULATED_PER_FLOW',
        1406: 'SHUTDOWN_DURATION',
        1407: 'PMGR_CNTR7_FE_PCIE_L1',
        1409: 'PMGR_CNTR7_FE_PCIE_L1_1',
        1410: 'PMGR_CNTR7_FE_PCIE_L1_2',
        1222: 'IDLE_ASR_ENTRY',
        1223: 'IDLE_ASR_EXIT',
        1224: 'IDLE_ASR_ENTRY_L1_1',
        1225: 'IDLE_CLOCK_GATED_INTERRUPTED',
        1226: 'LP_BOOT_TILL_FE_READY_DURATION',
        1227: 'HP_BOOT_TILL_FE_READY_DURATION',
        1228: 'WARM_BOOT_TILL_FE_ENABLE_DURATION',
        1229: 'IDLE_TILL_POWER_GATED_START_DURATION',
        1230: 'IDLE_POWER_GATED_ENTRY_DURATION',
        1231: 'BOOT_WITH_NON_DEFAULT_RVS',
        1233: 'MAXIMUM_IDLE_TILL_CLOCK_GATED_START_DURATION',
        1234: 'MAXIMUM_CLOCK_GATED_ENTRY_DURATION',
        1236: 'MAXIMUM_IDLE_TILL_ASR_START_DURATION',
        1237: 'MAXIMUM_ASR_ENTRY_DURATION',
        1238: 'LPSR_ENTRY',
        1239: 'LPSR_EXIT',
        1450: 'OOB_PACKETS_TRANSMITTED',
        1451: 'OOB_PACKETS_RECEIVED',
        1452: 'OOB_ERROR_PACKETS_GENERATED',
        1300: 'INDMB_UNITS_TOTAL',
        1301: 'INDMB_UNITS_XFER',
        1302: 'INDMB_UNITS_CACHE',
        1303: 'INDMB_UNITS_IND',
        1304: 'INDMB_XFER_COUNT_TO',
        1305: 'INDMB_ACCUMULATED_TIME_BETWEEN_XFERS',
        1457: 'WCACHE_FS_MB',
        1458: 'WCACHE_DS_MB',
        1460: 'NUM_UNKNOWN_TOKEN_HOST_READ',
        1461: 'NUM_UNMAPPED_TOKEN_HOST_READ',
        1462: 'NUM_THROTTLING_ENTRIES_PER_LEVEL',
        1463: 'WCACHE_FS_MB_MIN',
        1464: 'WCACHE_FS_MB_MAX',
        1470: 'SELF_THROTTLING_ENGAGE',
        1471: 'SELF_THROTTLING_DISENGAGE',
        1472: 'SELF_THROTTLING_IS_ENGAGED',
        1465: 'PREFETCH_READS',
        1466: 'PREFETCH_HITS',
        1467: 'PREFETCH_INVALIDATION_BY_WRITES',
        1500: 'PREPARE_FOR_SHUTDOWN_FAIL',
        1501: 'PREPARE_FOR_SHUTDOWN_TIMOUT',
        1502: 'PREPARE_FOR_SHUTDOWN_CANCEL',
        1503: 'HOST_WRITES_X_ACTS',
        1504: 'HOST_READS_X_ACTS',
        1506: 'HOST_READS',
        1507: 'VALID_LBAS',
        1508: 'SHUTDOWNS',
        1509: 'BOOTS',
        1510: 'UNCLEAN_BOOTS',
        1511: 'IND_POOLD_FREE',
        1512: 'IND_POOL_COUNT',
        1513: 'HOST_WRITE_LOG_HISTO',
        1514: 'HOST_READ_LOG_HISTO',
        1515: 'WEARLEVEL_MOVES',
        1516: 'NAND_READS',
        1517: 'BAND_ERASES',
        1518: 'NUM_REFRESHES',
        1519: 'CNT_TIME_WENT_BACKWARD_ON_BOOT',
        1520: 'CNT_TIME_WENT_BACKWARD',
        1521: 'SMART_CRIT_WARNINGS',
        1522: 'CLOG_READ',
        1523: 'MAX_HIGH_ENDURANCE_BLOCK_ERASES',
        1524: 'NUM_FACTORY_BAD',
        1525: 'NUM_GROWN_BAD',
        1526: 'NUM_FREE_VIRTUAL_BLOCKS',
        1527: 'BYTES_PER_PAGE',
        1528: 'PAGES_PER_VIRTUAL_BLOCK',
        1529: 'BLOCKS_PER_VIRTUAL_BLOCK',
        1530: 'EXPORT_VERSION',
        1531: 'EC_BINS',
        1532: 'RC_BINS',
        1533: 'UTIL_FORMAT_TIME',
        1534: 'CALENDAR_TIME',
        1535: 'WALL_TIME',
        1536: 'QOS_PER_COMMAND_Q',
        1537: 'MAX_QOS_PER_COMMAND_Q',
        1538: 'COMMAND_Q_FLUSH_US',
        1539: 'COMMAND_Q_UNMAP_US',
        1540: 'COMMAND_Q_PRIO0_R_US',
        1541: 'COMMAND_Q_PRIO0_W_US',
        1542: 'COMMAND_Q_PRIO1_R_US',
        1543: 'COMMAND_Q_PRIO1_W_US',
        1544: 'COMMAND_Q_PRIO2_R_US',
        1545: 'COMMAND_Q_PRIO2_W_US',
        1546: 'COMMAND_Q_PRIO3_R_US',
        1547: 'COMMAND_Q_PRIO3_W_US',
        1548: 'HOST_IDLE_MS',
        1549: 'COMMAND_HYSTERESIS_WINDOW_US',
        1550: 'COMMAND_RW_HYSTERESIS_US',
        1551: 'COMMAND_LOW_PRIO_HOLDOFF_DELAY_US',
        1552: 'COMMAND_LOW_PRIO_HOLDOFF_ENABLED',
        1553: 'COMMAND_EXPEDITE_NUM_SUCCESS',
        1554: 'COMMAND_EXPEDITE_NUM_FAILURES',
        1555: 'NUM_TRIM_ERASE',
        1556: 'STATIC_SIZE_IN_MB',
        1557: 'READ_COUNT_HISTO',
        1558: 'SLC_INVALIDATIONS',
        1559: 'SLC_GC_INVALIDATIONS',
        1560: 'HOST_SECTORS_DURING_GC_ON',
        1561: 'HIGH_WATER_MARK_SLC_USED',
        1562: 'INTERMIDIATE_BAND_ERASES',
        1563: 'INTERMIDIATE_PARTITION_START',
        1564: 'USER_PARTITION_START',
        1565: 'IOLOG_LBAS',
        1566: 'BANDS_AGE_BINS',
        1567: 'INTERMIDIATE_BANDS_AGE_BINS',
        1568: 'BDR_PADDING',
        1571: 'IND_CONTING_COUNT',
        1572: 'IND_VALID_CONTING_COUNT',
        1573: 'IND_MIN_CONTING_SIZE',
        1574: 'IND_MAX_CONTING_SIZE',
        1575: 'IND_AVG_CONTING_SIZE',
        1576: 'PHOTO_FLOW_MODE',
        1577: 'PAGES_PER_VIRTUAL_BLOCK_SLC',
        1578: 'BANDS_PER_HOST_FLOW',
        1579: 'BANDS_PER_SPECIAL_FLOW',
        1580: 'SECS_PER_HOST_FLOW',
        1581: 'SECS_PER_SPECIAL_FLOW',
        1582: 'OVER_WRITES_PER_HOST_FLOW',
        1583: 'OVER_WRITES_PER_SPECIAL_FLOW',
        1584: 'PAD_SECTORS_PER_FLOW',
        1585: 'PAD_SIZES',
        1586: 'UNMAP_PER_HOST_FLOW',
        1587: 'UNMAP_PER_SPECIAL_FLOW',
        1588: 'COLDEST_CYCLE',
        1589: 'HOTTEST_CYCLE',
        1590: 'GC_WRITES',
        1591: 'GC_LONLY_WRITES',
        1592: 'GC_PL_WRITES',
        1593: 'GC_FREE_L',
        1594: 'GC_DESTINATIONS',
        1595: 'GC_FRAGMENTS',
        1596: 'RAID_BANDS_PER_HOST_FLOW',
        1597: 'RAID_SECS_PER_HOST_FLOW',
        1598: 'BULK_PROGRAM',
        1599: 'BULK_READ',
        1600: 'BULK_SKIP_READ',
        1601: 'BULK_PARTIAL',
        1602: 'NUM_MEM_CHOKE',
        1603: 'MAX_MEM_CHOKE_DURATION',
        1604: 'NUM_MEM_EXTREME',
        1605: 'MAX_MEM_EXTREME_DURATION',
        1606: 'MEM_EXTREME_DURATION',
        1607: 'NUM_MEM_LOW',
        1608: 'MAX_MEM_LOW_DURATION',
        1609: 'MEM_LOW_DURATION',
        1610: 'BAND_GETS_EXTREME',
        1611: 'BAND_GETS_LOW',
        1613: 'NUM_HOST_CHOKE',
        1614: 'DFRAG_M_FROM_ORPHANS',
        1615: 'DFRAG_M_FROM_FRAGMENTS',
        1616: 'DFRAG_M_TIME',
        1617: 'DFRAG_M_MAX_TIME',
        1618: 'POWER_ON_SECONDS',
        1619: 'WCACHE_FS_WR',
        1620: 'WCACHE_DS_WR',
        1621: 'WCACHE_FS_EVICT_COUNT',
        1622: 'WCACHE_FS_EVICT_SIZE',
        1623: 'WCACHE_FS_EVICT_SIZE_LOG_DIST',
        1624: 'RD_OPEN_BAND_COUNT',
        1625: 'RD_OPEN_BAND_NOPS',
        1626: 'RD_CLOSED_BAND_EVICT_COUNT',
        1627: 'RD_CLOSED_BAND_EVICT_SECTORS',
        1628: 'UNGRACEFULBOOT_WORST_INDICATOR',
        1629: 'WCACHE_FSOVERWRLOGSIZECNTS',
        1630: 'WCACHE_FSOVERWRSIZEBYFLOW',
        1631: 'MAXGRACEFULBOOTTIMEMS',
        1632: 'MAXUNGRACEFULBOOTTIMEMS',
        1633: 'AVERAGEGRACEFULBOOTTIMEMS',
        1634: 'AVERAGEUNGRACEFULBOOTTIMEMS',
        1635: 'GRACEFULBOOTTIMELOGMS',
        1636: 'UNGRACEFULBOOTTIMELOGMS',
        1637: 'COMMAND_OLDEST_EVER',
        1638: 'COMMAND_OLDEST_THIS_SEC',
        1639: 'ABORTSKIP_WLP',
        1640: 'HOST_WRITES_WLP_MODE',
        1641: 'HOST_WLP_STATUS',
        1642: 'BOOT_BLOCKS_LOCATION',
        1643: 'NUM_FW_UPDATES',
        1644: 'NUM_FW_REFRESH_FROM_BACKUP',
        1800: 'NUM_CONSEQ_FW_REFRESH_FROM_BACKUP',
        1645: 'NUM_FW_BURN_ERR',
        1646: 'DFW_REFRESH_STATE_BITMAP',
        1647: 'READ_AMP_HISTO',
        1648: 'TOTAL_READ_AMP',
        1649: 'ALGO_FORCE_STATE',
        1650: 'NUM_UNSUPPORTED_ASI_SENT',
        1670: 'DRAM_ALLOCATION',
        1811: 'BG_INIT_DURATION',
        1812: 'NVME_MODE_NORMAL_RW',
        1813: 'NVME_MODE_BOOT',
        1814: 'NVME_MODE_NORMAL_RO',
        1815: 'NVME_MODE_RECOVERY',
        1816: 'NUM_BOOT_BLOCK_REFRESH_SUCCESS',
        1817: 'NUM_BOOT_BLOCK_REFRESH_FAIL',
        1818: 'NUM_TERMINATED_PROGRAM_SEGS',
        1823: 'POWER_BUDGET_SELECT',
        1824: 'INDFLOW_PROGRAMS',
        1829: 'E2E_DP_ERROR_COUNTERS',
        1830: 'MSP_BOOT_BLOCK_READ_FAIL',
        1831: 'MSP_BOOT_BLOCK_PROG_FAIL',
        1832: 'MSP_BOOT_BLOCK_ERASE_FAIL',
        1833: 'BANDS_REFRESHED_ON_ERROR',
        1834: 'BANDS_MAX_TEMP_HISTO',
        1835: 'BANDS_MIN_TEMP_HISTO',
        1836: 'BANDS_LIFETIME_TEMP_HISTO',
        1837: 'BANDS_DELTA_TEMP_HISTO',
        1838: 'BANDS_CROSS_TEMP_HISTO',
        1839: 'HOST_WRITES_PER_HOST',
        1840: 'HOST_READS_PER_HOST',
        1841: 'HOST_WRITES_X_ACTS_PER_HOST',
        1842: 'HOST_READS_X_ACTS_PER_HOST',
        1843: 'HOST_FLUSH_PER_HOST',
        1844: 'HOST_FENCE_PER_HOST',
        1845: 'INTERMEDIATE_BAND_ERASES',
        1846: 'WCACHE_SECTORS_MAX',
        1847: 'WCACHE_SECTORS_MIN',
        1848: 'WCACHE_SECTORS_CUR',
        1849: 'WCACHE_DS_SECTORS_MAX',
        1850: 'WCACHE_DS_SECTORS_MIN',
        1851: 'WCACHE_DS_SECTORS_CUR',
        1852: 'WCACHE_FS_READS',
        1853: 'WCACHE_DS_READS',
        1854: 'WCACHE_DSOVERWRLOGSIZECNTS',
        1855: 'WCACHE_DSOVERWRSIZEBYFLOW',
        1856: 'CMD_RAISE_PRIORITY_EVENTS',
        1863: 'MAX_CLOG_BANDS',
        1864: 'MAX_IND_BANDS',
        1866: 'WAIT_FOR_COLD_POWER_UP_DONE_MSG',
        1867: 'WAIT_FOR_WARM_POWER_UP_DONE_MSG',
        1868: 'MAXIMUM_WAIT_FOR_COLD_POWER_UP_DONE_MSG',
        1869: 'MAXIMUM_WAIT_FOR_WARM_POWER_UP_DONE_MSG',
        1870: 'STORAGE_DEVICE_PCYCLE_AFTER_S2R',
        1871: 'LAST_IDLE_TILL_POWER_GATED_START_DURATION',
        1872: 'S2R_ENTER_TIME_DURATION',
        1873: 'MAXIMUM_S2R_ENTER_TIME_DURATION',
        1874: 'S2R_EXIT_TIME_DURATION',
        1875: 'MAXIMUM_S2R_EXIT_TIME_DURATION',
        1876: 'MAXIMUM_SHUTDOWN_NORMAL_DURATION',
        1877: 'SHUTDOWN_S2R_DURATION',
        1878: 'MAXIMUM_SHUTDOWN_S2R_DURATION',
        1879: 'INIT_DURATION',
        1880: 'MAXIMUM_INIT_DURATION',
        1887: 'SHUTDOWN_NORMAL_DURATION',
        1889: 'CHIP_ID_TEMPERATURE_SAMPLE',
        1890: 'WCACHE_DS_SEGS_SORTED_LOG_SIZE',
        1891: 'WCACHE_WAIT_LOG_MS',
        1892: 'GC_ON_NUM_BANDS',
        1893: 'GC_OFF_INTERMEDIATE_NUM_BANDS',
        1894: 'GC_OFF_USER_NUM_BANDS',
        1895: 'NUM_FREE_INTERMEDIATE_BANDS',
        1896: 'NUM_FREE_USER_BANDS',
        65535: 'ENDOFSYSTEMCOUNTERS'
    }
    return dictionary.get(counter_id, "UNKNOWN")


# Get S3E/S3X system counters, and parse the buffer.
def s3_get_sys_counters(ctl, info, args):
    max_size = 1 << 20
    data = nvmectl.ucharArray(max_size)

    retval = ctl.ReadDebugData(data, max_size, 4, 0, 0)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Read Debug Data (syscounters)', r=retval)))
        return retval.fReturn

    data_len = retval.fCommandSpecificData

    if args.string_name:
        print(("{:<7} {:<50} {:<7} {:<7}".format('ID', 'NAME', 'LENGTH', 'VALUE')))
    else:
        print(("{:<7} {:<7} {:<7}".format('ID', 'LENGTH', 'VALUE')))
    data_index = 0
    while data_index < data_len:
        counter_id = data[data_index] + (data[data_index + 1] << 8)
        data_index += 2
        counter_len = data[data_index] + (data[data_index + 1] << 8)
        data_index += 2
        counter_value = ""
        for i in range(counter_len):
            counter_value = "{:02x}".format(data[data_index + i]) + counter_value
        if args.string_name:
            print(("{:<7} {:<50} {:<7} {}".format(counter_id, get_counter_name(counter_id), counter_len, counter_value)))
        else:
            print(("{:<7} {:<7} {}".format(counter_id, counter_len, counter_value)))
        data_index += counter_len

    return 0

s3_sys_counters_parser = nvmectlparser.subparsers.add_parser("S3GetSysCounters", help="Extract and parse S3E/S3X system counters.")
s3_sys_counters_parser.add_argument("-s", "--string-name", action="store_true", help="Try to print the name of each counter.")
s3_sys_counters_parser.set_defaults(func=s3_get_sys_counters)


def print_slbt_data(data):
    print(('{:<40}{}'.format('MAGIC', data.MAGIC)))
    print(('{:<40}{}'.format('AMOUNT_OF_CYCLES_FROM_SOL', data.AMOUNT_OF_CYCLES_FROM_SOL)))
    print(('{:<40}{}'.format('AMOUNT_OF_SLBT_RUN', data.AMOUNT_OF_SLBT_RUN)))

    print(('{:<40}{}'.format('DRIVE_INFO.OFW_VERSION', data.DRIVE_INFO.OFW_VERSION)))
    print(('{:<40}{:<016X}'.format('DRIVE_INFO.SERIAL_NUMBER', data.DRIVE_INFO.SERIAL_NUMBER)))
    print(('{:<40}{}'.format('DRIVE_INFO.VENDOR_ID', data.DRIVE_INFO.VENDOR_ID)))
    print(('{:<40}{}'.format('DRIVE_INFO.PACKAGE_TYPE', data.DRIVE_INFO.PACKAGE_TYPE)))
    print(('{:<40}{}'.format('DRIVE_INFO.NAND_LITHOGRAOHY', data.DRIVE_INFO.NAND_LITHOGRAOHY)))
    print(('{:<40}{}'.format('DRIVE_INFO.NAND_DENSITY', data.DRIVE_INFO.NAND_DENSITY)))
    print(('{:<40}{}'.format('DRIVE_INFO.NAND_TECHNOLOGY', data.DRIVE_INFO.NAND_TECHNOLOGY)))
    print(('{:<40}{}'.format('DRIVE_INFO.NAND_REVISION', data.DRIVE_INFO.NAND_REVISION)))
    print(('{:<40}{}'.format('DRIVE_INFO.NAND_CAPACITY', data.DRIVE_INFO.NAND_CAPACITY)))
    print(('{:<40}{}'.format('DRIVE_INFO.RESERVED', data.DRIVE_INFO.RESERVED)))

    print(('{:<40}{}'.format('U_CYCLES', data.U_CYCLES)))
    print(('{:<40}{:<8} {:<8} {:<8}'.format('U_SERIAL_CYCLE', data.U_SERIAL_CYCLE0, data.U_SERIAL_CYCLE1, data.U_SERIAL_CYCLE2)))
    print(('{:<40}{:<8} {:<8}'.format('U_OPEN_BLOCK_CYCLE', data.U_OPEN_BLOCK_CYCLE0, data.U_OPEN_BLOCK_CYCLE1)))
    print(('{:<40}{}'.format('U_SP_DELAY_CYCLE', data.U_SP_DELAY_CYCLE)))
    print(('{:<40}{}'.format('U_CYCLE_PCT', data.U_CYCLE_PCT)))
    print(('{:<40}{}'.format('U_START_BLOCK', data.U_START_BLOCK)))
    print(('{:<40}{}'.format('U_END_BLOCK', data.U_END_BLOCK)))

    print('')
    for i in range(data.U_CYCLES):
        cycle = nvmectl.NVMeCTL_bufToSLBTCycPerf(data.CYCLES_STATISTICS_TABLE, i)
        print(('{:<40}{}'.format('CYCLE[{}].PROGRAM_TICKS'.format(i), cycle.PROGRAM_TICKS)))
        print(('{:<40}{}'.format('CYCLE[{}].PROGRAM_TIME'.format(i), cycle.PROGRAM_TIME)))
        print(('{:<40}{}'.format('CYCLE[{}].READ_TIME'.format(i), cycle.READ_TIME)))
        print(('{:<40}{}'.format('CYCLE[{}].TOTAL_TIME'.format(i), cycle.TOTAL_TIME)))
        print(('{:<40}{}'.format('CYCLE[{}].PROGRAM_OPS'.format(i), cycle.PROGRAM_OPS)))
        print(('{:<40}{}'.format('CYCLE[{}].READ_OPS'.format(i), cycle.READ_OPS)))
        print(('{:<40}{}'.format('CYCLE[{}].PROGRAM_PERF'.format(i), cycle.PROGRAM_PERF)))
        print(('{:<40}{}'.format('CYCLE[{}].READ_PERF'.format(i), cycle.READ_PERF)))
        print('')

    print(('{:<40}{}'.format('TOTAL_NUMBER_OF_ERRORS_DESCRIBED', data.TOTAL_NUMBER_OF_ERRORS_DESCRIBED)))
    print(('{:<40}{}'.format('BLOCK_TO_SAVE_SLBT_DATA', data.BLOCK_TO_SAVE_SLBT_DATA)))
    print('')

    for i in range(data.TOTAL_NUMBER_OF_ERRORS_DESCRIBED):
        gbb = nvmectl.NVMeCTL_bufToSLBTGBB(data.ERRORS_LIST, i)
        print(('{:<40}{}'.format('ERROR[{}].GBB_VALID'.format(i), gbb.GBB_VALID)))
        print(('{:<40}{}'.format('ERROR[{}].GBB_CYCLENUMBER'.format(i), gbb.GBB_CYCLENUMBER)))
        print(('{:<40}{}'.format('ERROR[{}].GBB_MODE'.format(i), gbb.GBB_MODE)))
        print(('{:<40}{}'.format('ERROR[{}].GBB_FAILURE_TYPE'.format(i), gbb.GBB_FAILURE_TYPE)))
        print(('{:<40}{}'.format('ERROR[{}].GBB_FAILURE_CH'.format(i), gbb.GBB_FAILURE_CH)))
        print(('{:<40}{}'.format('ERROR[{}].GBB_MEASURED_VALUE'.format(i), gbb.GBB_MEASURED_VALUE)))
        print(('{:<40}{}'.format('ERROR[{}].GBB_FAILURE_DIE'.format(i), gbb.GBB_FAILURE_DIE)))
        print(('{:<40}{}'.format('ERROR[{}].GBB_FAILURE_BLOCK'.format(i), gbb.GBB_FAILURE_BLOCK)))
        print(('{:<40}{}'.format('ERROR[{}].GBB_FAILURE_PAGE'.format(i), gbb.GBB_FAILURE_PAGE)))
        print(('{:<40}{}'.format('ERROR[{}].GBB_FAILURE_CHUNK'.format(i), gbb.GBB_FAILURE_CHUNK)))
        print('')

    print(('{:<40}{}'.format('TEMP_DATA.MIN', data.TEMP_DATA.MIN)))
    print(('{:<40}{}'.format('TEMP_DATA.MAX', data.TEMP_DATA.MAX)))
    print(('{:<40}{}'.format('TEMP_DATA.AVG', data.TEMP_DATA.AVG)))


# Get PTS_DATA and parse the SLBT data from it.
def get_slbt_data(ctl, info, args):
    max_size = 1 << 20
    data = nvmectl.ucharArray(max_size)

    retval = ctl.ReadDebugData(data, max_size, nvmectl.kNVMeDebugLogPTSData, 0, 0)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Read Debug Data (PTS data)', r=retval)))
        return retval.fReturn

    data_len = retval.fCommandSpecificData

    data_index = 0
    slbt_index = 0
    while data_index < data_len:
        item_id = data[data_index] + (data[data_index + 1] << 8)
        data_index += 2
        item_len = (data[data_index] + (data[data_index + 1]) << 8)
        data_index += 2
        if item_id == 0xff20:
            if slbt_index == args.s4e_index:
                slbt_data = nvmectl.NVMeCTL_bufToSLBTData(data, data_index)
                print_slbt_data(slbt_data)
                return 0
            else:
                slbt_index += 1
        data_index += item_len

    print('Error: SLBT data was not found in PTS data.')
    return 1

slbt_parser = nvmectlparser.subparsers.add_parser("GetSLBTData", help="Extract and parse SLBT data.")
slbt_parser.add_argument("s4e_index", type=nvmectlparser.nonnegative, help="The S4E index to get SLBT data for.")
slbt_parser.set_defaults(func=get_slbt_data)


def bin_get_field(num, start, len):
    return ((num & (((1 << len) - 1) << start)) >> start)


def print_band_info(index, info):
    GCcan = bin_get_field(info.FLAGS, 0, 1)
    GCmust = bin_get_field(info.FLAGS, 1, 1)
    GCrd = bin_get_field(info.FLAGS, 2, 1)
    special = bin_get_field(info.FLAGS, 3, 1)
    mode = bin_get_field(info.FLAGS, 4, 2)

    if info.VALID == 0xFFFFFFFF:
        valid = 'NA'
    else:
        valid = '{}'.format(info.VALID)

    print(("band: {:>4}\tflow: {:>2}\tvalid: {:>5}\terases: {:5}\tage: {:5}\tGCcan: {} GCmust: {} GCrd: {} special: {} mode: {}".format(
          index, info.FLOW, valid, info.ERASE_CYCLES, info.AGE, GCcan, GCmust, GCrd, special, mode)))


# Get S3E/S3X band stats, and parse the buffer.
def get_band_stats(ctl, info, args):
    max_size = 1 << 20
    data = nvmectl.intArray(max_size)

    retval = ctl.ReadDebugData(data, max_size, nvmectl.kNVMeDebugLogIDBandStats, 0, 0)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Read Debug Data (band stats)', r=retval)))
        return retval.fReturn

    data_len = retval.fCommandSpecificData

    num_bands = data[0]
    num_partitions = data[1]
    print(("DATA_LEN: {:<10} NUM_PARTITIONS: {:<10} NUM_BANDS: {:<10}".format(data_len, num_partitions, num_bands)))
    print("")

    for index in range(num_bands):
        band_info = ctl.GetBandinfo(data, num_bands, num_partitions, index)
        print_band_info(index, band_info)

    return 0

band_stats_parser = nvmectlparser.subparsers.add_parser("GetBandStats", help="Extract and parse S3E/S3X band stats.")
band_stats_parser.set_defaults(func=get_band_stats)


def get_board_type(ctl, args):
    data = nvmectl.NVMeIdentifyControllerStruct()
    ret = ctl.IdentifyController(data)
    if ret.fReturn != 0 or ret.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Identify', r=ret)))
        return None

    board_type_string = nvmectl.NVMeCTL_GetBoardTypeString(data.BOARD_TYPE)
    if args.verbose:
        print(('board_type={}'.format(board_type_string)))
    return board_type_string


def print_gbb_defect(index, defect, num_planes):
    reasons = {
        0: 'FACTORY',
        1: 'EFAIL',
        2: 'PFAIL',
        3: 'UNC',
        4: 'RFAIL_BONFIRE',
        5: 'RVFAIL',
        6: 'UTIL',
        7: 'UTIL_EFAIL',
        8: 'UTIL_PFAIL',
        9: 'UTIL_UNC',
        10: 'REFRESH',
        11: 'RXBURN_REFRESH',
        12: 'UTIL_REFRESH',
        13: 'RETIRE',
        14: 'UTIL_RETIRE',
        15: 'RXBURN_REL_REFRESH',
        30: 'VERTICAL_DESTINATION',
        31: 'VERTICAL_ORPHAN'
    }

    defect_modes = {
        0: 'MLC',
        1: 'TLC',
        2: 'SLC',
        3: 'SLC_HE'
    }

    msp = defect.BUS // 2
    ch = defect.BUS % 2
    die = defect.CAU // num_planes
    plane = defect.CAU % num_planes
    block = defect.BAND
    page = defect.PAGE

    reason = defect.REASON % 100
    reason_text = reasons.get(reason, 'INVALID ({})'.format(defect.REASON))

    prog_type = defect_modes.get(defect.DEFECT_MODE, 'INVALID ({})'.format(defect.DEFECT_MODE))

    print(('MSP={:<7} CH={:<7} DIE={:<7} PLANE={:<7} BLOCK={:<7} PAGE={:<7} CYCLES={:<5} TEMP={:<5} REASON={:<22} TYPE={}'.format(
          msp, ch, die, plane, block, page, defect.CYCLES, defect.TEMP, reason_text, prog_type)))


# Get S3E/S3X grown bad blocks list.
def get_gbb(ctl, info, args):
    max_size = 1 << 20
    data = nvmectl.intArray(max_size)

    retval = ctl.ReadDebugData(data, max_size, nvmectl.kNVMeDebugLogIDGBB, 1, 0)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Read Debug Data (GBB)', r=retval)))
        return retval.fReturn

    data_len = retval.fCommandSpecificData
    if data_len == 0:
        print('Error: Read debug returned no data.')
        return 1

    factory_bad_count = data[1]
    grown_bad_count = data[2]

    if grown_bad_count == 0:
        print('No grown bad blocks.')
        return 0

    identify_data = nvmectl.NVMeIdentifyControllerStruct()
    retval = ctl.IdentifyController(identify_data)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Identify', r=retval)))
        return 1

    density = bin_get_field(identify_data.S3_DEVICE_DESCRIPTOR, 7, 2)
    num_planes = 1 << bin_get_field(identify_data.S3_DEVICE_DESCRIPTOR, 12, 2)

    if args.verbose:
        print(('num_planes={} density={}'.format(num_planes, density)))
    for index in range(grown_bad_count):
        defect = ctl.GetGBBDefect(data, index)
        print_gbb_defect(index, defect, num_planes)

    print('')
    print(('Summary: FACTORY_BAD_COUNT: {:<10} GROWN_BAD_COUNT: {:<10}'.format(factory_bad_count, grown_bad_count)))

    return 0

gbb_parser = nvmectlparser.subparsers.add_parser("GetGBB", help="Extract and parse S3E/S3X Grown bad blocks.")
gbb_parser.set_defaults(func=get_gbb)


def get_nand_geom(ctl):
    geom = nvmectl.S3NANDGeomStruct()
    retval = ctl.GetNANDGeometry(geom)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='GetNANDGeometry', r=retval)))
        return None
    geom_v2 = nvmectl.NVMeCTL_CheckV2Geom(geom, retval.fCommandSpecificData)
    if geom_v2:
        print("returning v2")
        return geom_v2
    else:
        print("returning v1")
        return geom


def print_nand_geom(ctl, info, args):
    geom = get_nand_geom(ctl)
    if geom is None:
        return 1

    try:
        print(('{:<40}{}'.format('CE_PER_BUS', geom.GEOM.CE_PER_BUS)))
        print(('{:<40}{}'.format('DIE_PER_BUS', geom.GEOM.DIE_PER_BUS)))
    except AttributeError:
        dies_per_bus = [ctl.u8ArrayGet(geom.GEOM.DIES_PER_BUS, i) for i in range(geom.GEOM.NUM_BUS)]
        print(('{:<40}{}'.format('DIES_PER_BUS', ' '.join(map(str, dies_per_bus)))))
    print(('{:<40}{}'.format('CAU_PER_DIE', geom.GEOM.CAU_PER_DIE)))
    print(('{:<40}{}'.format('NUM_BUS', geom.GEOM.NUM_BUS)))
    print(('{:<40}{}'.format('NUM_DIP', geom.GEOM.NUM_DIP)))
    print(('{:<40}{}'.format('NUM_BANDS', geom.GEOM.NUM_BANDS)))
    print(('{:<40}{}'.format('SEC_PER_PAGE', geom.GEOM.SEC_PER_PAGE)))
    print(('{:<40}{}'.format('SEC_PER_FULL_BAND', geom.GEOM.SEC_PER_FULL_BAND)))
    print(('{:<40}{}'.format('SEC_PER_FULL_BAND_SLC', geom.GEOM.SEC_PER_FULL_BAND_SLC)))
    print(('{:<40}{}'.format('BYTES_PER_SEC_META', geom.GEOM.BYTES_PER_SEC_META)))
    print(('{:<40}{}'.format('PAGES_PER_BLOCK', geom.GEOM.PAGES_PER_BLOCK)))
    print(('{:<40}{}'.format('PAGES_PER_BLOCK_SLC', geom.GEOM.PAGES_PER_BLOCK_SLC)))
    print(('{:<40}{}'.format('PAGES_PER_BLOCK0', geom.GEOM.PAGES_PER_BLOCK0)))
    cell_type_map = {1: 'SLC', 2: 'MLC', 3: 'TLC'}
    print(('{:<40}{}'.format('CELL_TYPE', cell_type_map.get(geom.GEOM.CELL_TYPE, 'UNKNOWN (%d)' % geom.GEOM.CELL_TYPE))))
    print(('{:<40}{}'.format('PAGES_IN_READ_VERIFY', geom.GEOM.PAGES_IN_READ_VERIFY)))
    print(('{:<40}{}'.format('EOL_BLOCKS', geom.GEOM.EOL_BLOCKS)))
    print(('{:<40}{}'.format('BLOCK_PAIRING_SCHEME', geom.GEOM.BLOCK_PAIRING_SCHEME)))
    print(('{:<40}{}'.format('PROGRAM_SCHEME', geom.GEOM.PROGRAM_SCHEME)))

    return 0

nand_geom_parser = nvmectlparser.subparsers.add_parser("GetNANDGeometry", help="Extract and parse NAND geometry.")
nand_geom_parser.set_defaults(func=print_nand_geom)


dip_info = namedtuple('dip_info', ['cau', 'ce', 'bus'])


def get_dip_info(ctl, dip_index):
    options = nvmectl.intArray(20)
    options[4] = dip_index

    retval = ctl.Tunnel(tunnel_types["core"], 0x36, options, None, 0)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Tunnel', r=retval)))
        return None

    info_int = options[2] & 0xFFFF
    info = dip_info(bin_get_field(info_int, 0, 7),
                    bin_get_field(info_int, 7, 1),
                    bin_get_field(info_int, 8, 3))

    return info


def print_dip_info(ctl, info, args):
    dip_info = get_dip_info(ctl, args.dip_index)
    if dip_info is None:
        return 1

    print(('CAU: {}'.format(dip_info.cau)))
    print(('CE:  {}'.format(dip_info.ce)))
    print(('BUS: {}'.format(dip_info.bus)))
    return 0

dip_info_parser = nvmectlparser.subparsers.add_parser("GetDIPInfo", help="Extract and parse Info for a given die in plane(DIP).")
dip_info_parser.add_argument("dip_index", type=nvmectlparser.nonnegative, help="The index of the queried DIP.")
dip_info_parser.set_defaults(func=print_dip_info)


def get_bbt(ctl, info, args):
    geom = get_nand_geom(ctl)
    if geom is None:
        return 1

    bbt_len = 4096 * geom.GEOM.NUM_DIP
    bbt = nvmectl.ucharArray(bbt_len)

    retval = ctl.Tunnel(tunnel_types["core"], 0x35, None, bbt, bbt_len)
    if retval.fReturn != 0 or retval.fNVMeStatus != 0:
        print((nvmectlparser.error_str.format(cmd='Tunnel', r=retval)))
        return 1

    if args.output_file is not None:
        print(('Writing {} bytes to {}.'.format(bbt_len, args.output_file)))
        ctl.WriteBufferToFile(bbt, bbt_len, args.output_file)
        return 0

    bus_per_msp = 2
    num_fbb = 0
    for dip in range(geom.GEOM.NUM_DIP):
        dip_info = get_dip_info(ctl, dip)
        for block in range(geom.GEOM.NUM_BANDS):
            try:
                vdip = (dip_info.bus * geom.GEOM.DIE_PER_BUS * geom.GEOM.CAU_PER_DIE) + dip_info.cau
            except AttributeError:
                ndip = 0
                for i in range(dip_info.bus):
                    ndip += geom.GEOM.DIES_PER_BUS[i]
                vdip = (ndip * geom.GEOM.CAU_PER_DIE) + dip_info.cau
            if vdip >= geom.GEOM.NUM_DIP:
                print(('Error: Invalid vdip (dip={} vdip={}).'.format(dip, vdip)))
                return 1
            byte_index = (4096 * vdip) + block // 8
            byte = bbt[byte_index]
            bit_index = 7 - (block % 8)
            if byte & (1 << bit_index) != 0:
                num_fbb += 1
                print(('DIP={:<7} BLOCK={:<7} MSP={:<7} CH={:<7} DIE={:<7} PLANE={:<7}'.format(
                    dip,
                    block,
                    dip_info.bus // bus_per_msp,
                    dip_info.bus % bus_per_msp,
                    dip_info.cau // geom.GEOM.CAU_PER_DIE,
                    dip_info.cau % geom.GEOM.CAU_PER_DIE)))

    print(('\nSummary: FACTORY_BAD_COUNT: {:<10}'.format(num_fbb)))
    return 0

bbt_parser = nvmectlparser.subparsers.add_parser("GetBBT", help="Extract and parse factory bad block table.")
bbt_parser.add_argument("-f", "--output-file", help="Output the raw data as a binary to the specified file.")
bbt_parser.set_defaults(func=get_bbt)


# Create block device
def create_block_storage_device(ctl, info, args):
    retval = ctl.CreateBlockStorageDevice()
    print((nvmectlparser.status_str.format(r=retval)))

    return retval.fReturn

create_blockdev_parser = nvmectlparser.subparsers.add_parser("CreateBlockStorageDevice", help="Create Block storage device.")
create_blockdev_parser.set_defaults(func=create_block_storage_device)


# destroy block device
def destroy_block_storage_device(ctl, info, args):
    retval = ctl.DestroyBlockStorageDevice()
    print((nvmectlparser.status_str.format(r=retval)))

    return retval.fReturn

destroy_blockdev_parser = nvmectlparser.subparsers.add_parser("DestroyBlockStorageDevice", help="Destroy Block storage device.")
destroy_blockdev_parser.set_defaults(func=destroy_block_storage_device)


# Unlock S1X system counters.
def s1x_sys_counters_unlock(ctl, info, args):
    retval = ctl.S1XSysCountersUnlock()
    print((nvmectlparser.status_str.format(r=retval)))

    return retval.fReturn

s1x_syscount_unlock_parser = nvmectlparser.subparsers.add_parser("S1XSysCountersUnlock", help="Unlock S1X system counters.")
s1x_syscount_unlock_parser.set_defaults(func=s1x_sys_counters_unlock)


# Check write protection.
def check_write_protection(ctl, info, args):
    retval = ctl.CheckWriteProtection()
    print(('status={:#x}'.format(retval)))

    return retval

check_write_protection_parser = nvmectlparser.subparsers.add_parser("CheckWriteProtection",
                                                                    help="Check drive's write protection, and set"
                                                                         " write protection flag accordingly.")
check_write_protection_parser.set_defaults(func=check_write_protection)


# Get NAND info.
def get_nand_info(ctl, info, args):
    data = nvmectl.uint64Array(1)
    status = ctl.GetNANDInfo(data.cast())

    if status != 0:
        print(('GetNANDInfo() failed. status={:#x}'.format(status)))
        return 1

    print(("NAND_DESCRIPTOR     {:016X}".format(data[0])))
    return 0

get_nand_info_parser = nvmectlparser.subparsers.add_parser("GetNANDInfo", help='Get NAND info from driver (a.k.a NAND descriptor).')
get_nand_info_parser.set_defaults(func=get_nand_info)
